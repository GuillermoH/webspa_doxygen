<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Webspa - grupo 4: Query Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Webspa - grupo 4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_cake_1_1_database_1_1_query.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Query Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Query:</div>
<div class="dyncontent">
<div class="center"><img src="class_cake_1_1_database_1_1_query__inherit__graph.png" border="0" usemap="#_query_inherit__map" alt="Inheritance graph"/></div>
<map name="_query_inherit__map" id="_query_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Query:</div>
<div class="dyncontent">
<div class="center"><img src="class_cake_1_1_database_1_1_query__coll__graph.png" border="0" usemap="#_query_coll__map" alt="Collaboration graph"/></div>
<map name="_query_coll__map" id="_query_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a155afedbdfa01f1c0b813ca97642cdab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a155afedbdfa01f1c0b813ca97642cdab">__construct</a> ($<a class="el" href="class_cake_1_1_database_1_1_query.html#ad1d6d1adc19d06409d065db3b9e55892">connection</a>)</td></tr>
<tr class="separator:a155afedbdfa01f1c0b813ca97642cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6d1adc19d06409d065db3b9e55892"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ad1d6d1adc19d06409d065db3b9e55892">connection</a> ($connection=null)</td></tr>
<tr class="separator:ad1d6d1adc19d06409d065db3b9e55892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1909f4b7f8129c7790cb75de2ffbe1e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a1909f4b7f8129c7790cb75de2ffbe1e4">execute</a> ()</td></tr>
<tr class="separator:a1909f4b7f8129c7790cb75de2ffbe1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad453d5675564710643f65cec433429cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ad453d5675564710643f65cec433429cc">sql</a> (<a class="el" href="class_cake_1_1_database_1_1_value_binder.html">ValueBinder</a> $generator=null)</td></tr>
<tr class="separator:ad453d5675564710643f65cec433429cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0fdf35270d29a9c4ade9ed8981bce6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#afb0fdf35270d29a9c4ade9ed8981bce6">traverse</a> (callable $visitor, array $parts=[])</td></tr>
<tr class="separator:afb0fdf35270d29a9c4ade9ed8981bce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbf6be7aea0c748e41c583d9cd3add2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a3fbf6be7aea0c748e41c583d9cd3add2">select</a> ($fields=[], $overwrite=false)</td></tr>
<tr class="separator:a3fbf6be7aea0c748e41c583d9cd3add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa95fca61cada5f4c2b5927392d7738"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a8fa95fca61cada5f4c2b5927392d7738">distinct</a> ($on=[], $overwrite=false)</td></tr>
<tr class="separator:a8fa95fca61cada5f4c2b5927392d7738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3e2d4e2e65ad667955b49ef623d57e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a7a3e2d4e2e65ad667955b49ef623d57e">modifier</a> ($modifiers, $overwrite=false)</td></tr>
<tr class="separator:a7a3e2d4e2e65ad667955b49ef623d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b50b832a6e23bdd80c8feb766fc0475"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a9b50b832a6e23bdd80c8feb766fc0475">from</a> ($tables=[], $overwrite=false)</td></tr>
<tr class="separator:a9b50b832a6e23bdd80c8feb766fc0475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabf00d3fd2bf13bd4ce64d54d52e0f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#aaabf00d3fd2bf13bd4ce64d54d52e0f3">join</a> ($tables=null, $types=[], $overwrite=false)</td></tr>
<tr class="separator:aaabf00d3fd2bf13bd4ce64d54d52e0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ee60532a19ce2ecfbe140b3e6121b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ab8ee60532a19ce2ecfbe140b3e6121b2">removeJoin</a> ($name)</td></tr>
<tr class="separator:ab8ee60532a19ce2ecfbe140b3e6121b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1419bc90aa65fc4566c9437ec0a561"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#adc1419bc90aa65fc4566c9437ec0a561">leftJoin</a> ($table, $conditions=[], $types=[])</td></tr>
<tr class="separator:adc1419bc90aa65fc4566c9437ec0a561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f6d928a297d2d453041ed014e5ff99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a39f6d928a297d2d453041ed014e5ff99">rightJoin</a> ($table, $conditions=[], $types=[])</td></tr>
<tr class="separator:a39f6d928a297d2d453041ed014e5ff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef53c3c7f975a98f99c6e94669cfec75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#aef53c3c7f975a98f99c6e94669cfec75">innerJoin</a> ($table, $conditions=[], $types=[])</td></tr>
<tr class="separator:aef53c3c7f975a98f99c6e94669cfec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dad41b370250166fa451de4210f0654"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a5dad41b370250166fa451de4210f0654">where</a> ($conditions=null, $types=[], $overwrite=false)</td></tr>
<tr class="separator:a5dad41b370250166fa451de4210f0654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b997be67f940d99a5e31b7772926f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a80b997be67f940d99a5e31b7772926f5">andWhere</a> ($conditions, $types=[])</td></tr>
<tr class="separator:a80b997be67f940d99a5e31b7772926f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42526c0e77be52c51f583780cb9b69ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a42526c0e77be52c51f583780cb9b69ac">orWhere</a> ($conditions, $types=[])</td></tr>
<tr class="separator:a42526c0e77be52c51f583780cb9b69ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bf3a780d938bcd45aa9913ec4c645e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ad1bf3a780d938bcd45aa9913ec4c645e">order</a> ($fields, $overwrite=false)</td></tr>
<tr class="separator:ad1bf3a780d938bcd45aa9913ec4c645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3af23d370e24a90397a4aba1093e952"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ab3af23d370e24a90397a4aba1093e952">orderAsc</a> ($field, $overwrite=false)</td></tr>
<tr class="separator:ab3af23d370e24a90397a4aba1093e952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860119509d9f8e4ad15014c3332b3f1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a860119509d9f8e4ad15014c3332b3f1b">orderDesc</a> ($field, $overwrite=false)</td></tr>
<tr class="separator:a860119509d9f8e4ad15014c3332b3f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b89d7b9386040fe8e01d86b1f3ac09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#af5b89d7b9386040fe8e01d86b1f3ac09">group</a> ($fields, $overwrite=false)</td></tr>
<tr class="separator:af5b89d7b9386040fe8e01d86b1f3ac09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d33357f7c7174dc3ff20ff7f84fa3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ab7d33357f7c7174dc3ff20ff7f84fa3f">having</a> ($conditions=null, $types=[], $overwrite=false)</td></tr>
<tr class="separator:ab7d33357f7c7174dc3ff20ff7f84fa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abade3fb04898229e8ec1cfa073165c70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#abade3fb04898229e8ec1cfa073165c70">andHaving</a> ($conditions, $types=[])</td></tr>
<tr class="separator:abade3fb04898229e8ec1cfa073165c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe481cb16a86300021b5396368ced4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#affe481cb16a86300021b5396368ced4f">orHaving</a> ($conditions, $types=[])</td></tr>
<tr class="separator:affe481cb16a86300021b5396368ced4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe84bfa523332fc6735754f94bfe7538"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#abe84bfa523332fc6735754f94bfe7538">page</a> ($num, $<a class="el" href="class_cake_1_1_database_1_1_query.html#aa5fc5a54a6dc7a2b90e12bd7f11e04d0">limit</a>=null)</td></tr>
<tr class="separator:abe84bfa523332fc6735754f94bfe7538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fc5a54a6dc7a2b90e12bd7f11e04d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#aa5fc5a54a6dc7a2b90e12bd7f11e04d0">limit</a> ($num)</td></tr>
<tr class="separator:aa5fc5a54a6dc7a2b90e12bd7f11e04d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dadf1bda69ff9adbf83c83a5e77345"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a31dadf1bda69ff9adbf83c83a5e77345">offset</a> ($num)</td></tr>
<tr class="separator:a31dadf1bda69ff9adbf83c83a5e77345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817b2cf9717700a58bf428bf4a5ed3be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a817b2cf9717700a58bf428bf4a5ed3be">union</a> ($query, $overwrite=false)</td></tr>
<tr class="separator:a817b2cf9717700a58bf428bf4a5ed3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb352d987588edfca755a6cb565921a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#afb352d987588edfca755a6cb565921a9">unionAll</a> ($query, $overwrite=false)</td></tr>
<tr class="separator:afb352d987588edfca755a6cb565921a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa152062d7d481d7cdf981a5f38fccf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#aaa152062d7d481d7cdf981a5f38fccf4">insert</a> (array $columns, array $types=[])</td></tr>
<tr class="separator:aaa152062d7d481d7cdf981a5f38fccf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec3db58cf117fdf7ede0edf4d2c23b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a6ec3db58cf117fdf7ede0edf4d2c23b5">into</a> ($table)</td></tr>
<tr class="separator:a6ec3db58cf117fdf7ede0edf4d2c23b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f52cc4c6e1c23a1df054bede131cc40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a8f52cc4c6e1c23a1df054bede131cc40">values</a> ($data)</td></tr>
<tr class="separator:a8f52cc4c6e1c23a1df054bede131cc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f182bf26b338c017aad8c38aad4055"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a76f182bf26b338c017aad8c38aad4055">update</a> ($table)</td></tr>
<tr class="separator:a76f182bf26b338c017aad8c38aad4055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b2d42a061fd6bbd461fdd9d5f1e41a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a13b2d42a061fd6bbd461fdd9d5f1e41a">set</a> ($key, $value=null, $types=[])</td></tr>
<tr class="separator:a13b2d42a061fd6bbd461fdd9d5f1e41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ba2dace0c829f76af7ea7e4a4bb20e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a88ba2dace0c829f76af7ea7e4a4bb20e">delete</a> ($table=null)</td></tr>
<tr class="separator:a88ba2dace0c829f76af7ea7e4a4bb20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dfca507dd5223add337a02dfbac59b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ae6dfca507dd5223add337a02dfbac59b">epilog</a> ($expression=null)</td></tr>
<tr class="separator:ae6dfca507dd5223add337a02dfbac59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1e1faec5bf612c1ffc08f75907ec18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#adb1e1faec5bf612c1ffc08f75907ec18">type</a> ()</td></tr>
<tr class="separator:adb1e1faec5bf612c1ffc08f75907ec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38188a04a8fef17a2d9ef8111fc71910"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a38188a04a8fef17a2d9ef8111fc71910">newExpr</a> ($rawExpression=null)</td></tr>
<tr class="separator:a38188a04a8fef17a2d9ef8111fc71910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c6e659a89c18fa9459ec5341063fb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a17c6e659a89c18fa9459ec5341063fb8">func</a> ()</td></tr>
<tr class="separator:a17c6e659a89c18fa9459ec5341063fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9f937c2958e6f4dd7b030f86fb70b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a7a9f937c2958e6f4dd7b030f86fb70b7">getIterator</a> ()</td></tr>
<tr class="separator:a7a9f937c2958e6f4dd7b030f86fb70b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe86c34645d311bc31ec99d871a0a86b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#abe86c34645d311bc31ec99d871a0a86b">clause</a> ($name)</td></tr>
<tr class="separator:abe86c34645d311bc31ec99d871a0a86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e9fb73d6c774a2ea7f7b756a46bb23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a91e9fb73d6c774a2ea7f7b756a46bb23">decorateResults</a> ($callback, $overwrite=false)</td></tr>
<tr class="separator:a91e9fb73d6c774a2ea7f7b756a46bb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfc9c3a767a8ae6a65e7ab44ec55650"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a0cfc9c3a767a8ae6a65e7ab44ec55650">traverseExpressions</a> (callable $callback)</td></tr>
<tr class="separator:a0cfc9c3a767a8ae6a65e7ab44ec55650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d32a1384af7c0b4dc65861b2b86e844"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a1d32a1384af7c0b4dc65861b2b86e844">bind</a> ($param, $value, $<a class="el" href="class_cake_1_1_database_1_1_query.html#adb1e1faec5bf612c1ffc08f75907ec18">type</a>= 'string')</td></tr>
<tr class="separator:a1d32a1384af7c0b4dc65861b2b86e844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5c318570ef055323cb9695e7613b70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#acd5c318570ef055323cb9695e7613b70">valueBinder</a> ($binder=null)</td></tr>
<tr class="separator:acd5c318570ef055323cb9695e7613b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5eea85240ec1caf80860c4ca7961286"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#aa5eea85240ec1caf80860c4ca7961286">bufferResults</a> ($enable=null)</td></tr>
<tr class="separator:aa5eea85240ec1caf80860c4ca7961286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43183897a77655d4b11f3f099d4bb988"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a43183897a77655d4b11f3f099d4bb988">selectTypeMap</a> (<a class="el" href="class_cake_1_1_database_1_1_type_map.html">TypeMap</a> $<a class="el" href="namespace_cake_1_1_database.html#a3264218679f24cbca871006d1f205f62">typeMap</a>=null)</td></tr>
<tr class="separator:a43183897a77655d4b11f3f099d4bb988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cb87b388bc74d63dc884accdca8713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ad0cb87b388bc74d63dc884accdca8713">__clone</a> ()</td></tr>
<tr class="separator:ad0cb87b388bc74d63dc884accdca8713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7516ca30af0db3cdbf9a7739b48ce91d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a7516ca30af0db3cdbf9a7739b48ce91d">__toString</a> ()</td></tr>
<tr class="separator:a7516ca30af0db3cdbf9a7739b48ce91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca922c6f7bcc068784112a8e402a59f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#aca922c6f7bcc068784112a8e402a59f7">__debugInfo</a> ()</td></tr>
<tr class="separator:aca922c6f7bcc068784112a8e402a59f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_cake_1_1_database_1_1_expression_interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_cake_1_1_database_1_1_expression_interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interface_cake_1_1_database_1_1_expression_interface.html">ExpressionInterface</a></td></tr>
<tr class="memitem:a2a8c55dea45ca9c459835495e880dd4a inherit pub_methods_interface_cake_1_1_database_1_1_expression_interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_database_1_1_expression_interface.html#a2a8c55dea45ca9c459835495e880dd4a">traverse</a> (callable $visitor)</td></tr>
<tr class="separator:a2a8c55dea45ca9c459835495e880dd4a inherit pub_methods_interface_cake_1_1_database_1_1_expression_interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0d2cb8b18f03f12ee7eb88f62b6259ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a0d2cb8b18f03f12ee7eb88f62b6259ea">_makeJoin</a> ($table, $conditions, $<a class="el" href="class_cake_1_1_database_1_1_query.html#adb1e1faec5bf612c1ffc08f75907ec18">type</a>)</td></tr>
<tr class="separator:a0d2cb8b18f03f12ee7eb88f62b6259ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc72845c6c6f4e591b9100dbc961b67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#a2bc72845c6c6f4e591b9100dbc961b67">_decorateStatement</a> ($statement)</td></tr>
<tr class="separator:a2bc72845c6c6f4e591b9100dbc961b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ac301181b2663a06f3672fcd182463"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#ad7ac301181b2663a06f3672fcd182463">_conjugate</a> ($part, $append, $conjunction, $types)</td></tr>
<tr class="separator:ad7ac301181b2663a06f3672fcd182463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b00c8066b37bbceedbcb542e86db99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cake_1_1_database_1_1_query.html#aa4b00c8066b37bbceedbcb542e86db99">_dirty</a> ()</td></tr>
<tr class="separator:aa4b00c8066b37bbceedbcb542e86db99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab2085c8615e5ac8e3b910a7638c05b96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2085c8615e5ac8e3b910a7638c05b96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_connection</b></td></tr>
<tr class="separator:ab2085c8615e5ac8e3b910a7638c05b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41480551826add2f719e24e0d44b9715"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41480551826add2f719e24e0d44b9715"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_type</b> = '<a class="el" href="class_cake_1_1_database_1_1_query.html#a3fbf6be7aea0c748e41c583d9cd3add2">select</a>'</td></tr>
<tr class="separator:a41480551826add2f719e24e0d44b9715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475b901300c346a261d1393f62cfb763"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>$_parts</b></td></tr>
<tr class="separator:a475b901300c346a261d1393f62cfb763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56d7b9851ff33f2fe495cf7509a2cea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa56d7b9851ff33f2fe495cf7509a2cea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_dirty</b> = false</td></tr>
<tr class="separator:aa56d7b9851ff33f2fe495cf7509a2cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb01338144a432070368587c1d14741e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb01338144a432070368587c1d14741e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_resultDecorators</b> = []</td></tr>
<tr class="separator:adb01338144a432070368587c1d14741e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9d014d910e310f3162e33d909212fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae9d014d910e310f3162e33d909212fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_iterator</b></td></tr>
<tr class="separator:aae9d014d910e310f3162e33d909212fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aede7d44362e436a77cb1bd06acbc0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aede7d44362e436a77cb1bd06acbc0f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_valueBinder</b></td></tr>
<tr class="separator:a0aede7d44362e436a77cb1bd06acbc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cb60cd392c75683d3877232701f3dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31cb60cd392c75683d3877232701f3dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_functionsBuilder</b></td></tr>
<tr class="separator:a31cb60cd392c75683d3877232701f3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582ab00f2052e926db1f50f26a565ecf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a582ab00f2052e926db1f50f26a565ecf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_useBufferedResults</b> = true</td></tr>
<tr class="separator:a582ab00f2052e926db1f50f26a565ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ede6b48b6030766388cf4b50d9b6c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4ede6b48b6030766388cf4b50d9b6c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_selectTypeMap</b></td></tr>
<tr class="separator:ad4ede6b48b6030766388cf4b50d9b6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473d2ca3973c4425e6ae433f778740c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab473d2ca3973c4425e6ae433f778740c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>$_typeCastAttached</b> = false</td></tr>
<tr class="separator:ab473d2ca3973c4425e6ae433f778740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a Relational database SQL <a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a>. A query can be of different types like select, update, insert and delete. Exposes the methods for dynamically constructing each query part, execute it and transform it to a specific SQL dialect. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a155afedbdfa01f1c0b813ca97642cdab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__construct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">\Cake\Datasource\ConnectionInterface</td><td class="paramname">$connection</td><td>The connection object to be used for transforming and executing this query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad0cb87b388bc74d63dc884accdca8713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a deep clone on this object.</p>
<p>Will clone all of the expression objects used in each of the clauses, as well as the valueBinder.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aca922c6f7bcc068784112a8e402a59f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__debugInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array that can be used to describe the internal state of this object.</p>
<dl class="section return"><dt>Returns</dt><dd>array </dd></dl>

</div>
</div>
<a class="anchor" id="a7516ca30af0db3cdbf9a7739b48ce91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns string representation of this query (complete SQL statement).</p>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

</div>
</div>
<a class="anchor" id="ad7ac301181b2663a06f3672fcd182463"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_conjugate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conjunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function used to build conditions by composing QueryExpression objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$part</td><td>Name of the query part to append the new part to </td></tr>
    <tr><td class="paramtype">string&#160;|&#160;null&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;callable</td><td class="paramname">$append</td><td><a class="el" href="namespace_cake_1_1_database_1_1_expression.html">Expression</a> or builder function to append. </td></tr>
    <tr><td class="paramtype">string</td><td class="paramname">$conjunction</td><td>type of conjunction to be used to operate part </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a2bc72845c6c6f4e591b9100dbc961b67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_decorateStatement </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$statement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary function used to wrap the original statement from the driver with any registered callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">\Cake\Database\StatementInterface</td><td class="paramname">$statement</td><td>to be decorated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa4b00c8066b37bbceedbcb542e86db99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks a query as dirty, removing any preprocessed information from in memory caching.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a0d2cb8b18f03f12ee7eb88f62b6259ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_makeJoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an array that can be passed to the join method describing a single join clause</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array</td><td class="paramname">$table</td><td>The table to join with </td></tr>
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface</td><td class="paramname">$conditions</td><td>The conditions to use for joining. </td></tr>
    <tr><td class="paramtype">string</td><td class="paramname">$type</td><td>the join type to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array </dd></dl>

</div>
</div>
<a class="anchor" id="abade3fb04898229e8ec1cfa073165c70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">andHaving </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects any previously defined set of conditions to the provided list using the AND operator in the HAVING clause. This method operates in exactly the same way as the method <code><a class="el" href="class_cake_1_1_database_1_1_query.html#a80b997be67f940d99a5e31b7772926f5">andWhere()</a></code> does. Please refer to its documentation for an insight on how to using each parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;callable</td><td class="paramname">$conditions</td><td>The AND conditions for HAVING. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>::andWhere() </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a80b997be67f940d99a5e31b7772926f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">andWhere </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects any previously defined set of conditions to the provided list using the AND operator. This function accepts the conditions list in the same format as the method <code>where</code> does, hence you can use arrays, expression objects callback functions or strings.</p>
<p>It is important to notice that when calling this function, any previous set of conditions defined for this query will be treated as a single argument for the AND operator. This function will not only operate the most recently defined condition, but all the conditions as a whole.</p>
<p>When using an array for defining conditions, creating constraints form each array entry will use the same logic as with the <code><a class="el" href="class_cake_1_1_database_1_1_query.html#a5dad41b370250166fa451de4210f0654">where()</a></code> function. This means that each array entry will be joined to the other using the AND operator, unless you nest the conditions in the array using other operator.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line">$query-&gt;where([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;Hello World&#39;</span>)-&gt;andWhere([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1]);</div></div><!-- fragment --><p>Will produce:</p>
<p>`WHERE title = 'Hello World' AND author_id = 1`</p>
<div class="fragment"><div class="line">$query</div><div class="line">  -&gt;where([<span class="stringliteral">&#39;OR&#39;</span> =&gt; [<span class="stringliteral">&#39;published&#39;</span> =&gt; <span class="keyword">false</span>, <span class="stringliteral">&#39;published is NULL&#39;</span>]])</div><div class="line">  -&gt;andWhere([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;comments_count &gt;&#39;</span> =&gt; 10])</div></div><!-- fragment --><p>Produces:</p>
<p><code>WHERE (published = 0 OR published IS NULL) AND author_id = 1 AND comments_count &gt; 10</code></p>
<div class="fragment"><div class="line">$query</div><div class="line">  -&gt;where([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;Foo&#39;</span>])</div><div class="line">  -&gt;andWhere(<span class="keyword">function</span> ($exp, $query) {</div><div class="line">    <span class="keywordflow">return</span> $exp</div><div class="line">      -&gt;add([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1])</div><div class="line">      -&gt;or_([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 2]);</div><div class="line">  });</div></div><!-- fragment --><p>Generates the following conditions:</p>
<p>`WHERE (title = 'Foo') AND (author_id = 1 OR author_id = 2)`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;callable</td><td class="paramname">$conditions</td><td>The conditions to add with AND. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>::where() </dd>
<dd>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a1d32a1384af7c0b4dc65861b2b86e844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bind </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$type</em> = <code>'string'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates a query placeholder to a value and a type.</p>
<p>If type is expressed as "atype[]" (note braces) then it will cause the placeholder to be re-written dynamically so if the value is an array, it will create as many placeholders as values are in it. For example:</p>
<div class="fragment"><div class="line">$query-&gt;bind(<span class="stringliteral">&#39;:id&#39;</span>, [1, 2, 3], <span class="stringliteral">&#39;int[]&#39;</span>);</div></div><!-- fragment --><p>Will create 3 int placeholders. When using named placeholders, this method requires that the placeholders include <code>:</code> e.g. <code>:value</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;int</td><td class="paramname">$param</td><td>placeholder to be replaced with quoted version of $value </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$value</td><td>The value to be bound </td></tr>
    <tr><td class="paramtype">string&#160;|&#160;int</td><td class="paramname">$type</td><td>the mapped type name, used for casting when sending to database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="aa5eea85240ec1caf80860c4ca7961286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bufferResults </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$enable</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/Disable buffered results.</p>
<p>When enabled the results returned by this <a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a> will be buffered. This enables you to iterate a result set multiple times, or both cache and iterate it.</p>
<p>When disabled it will consume less memory as fetched results are not remembered for future iterations.</p>
<p>If called with no arguments, it will return whether or not buffering is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">bool&#160;|&#160;null</td><td class="paramname">$enable</td><td>whether or not to enable buffering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool|$this </dd></dl>

</div>
</div>
<a class="anchor" id="abe86c34645d311bc31ec99d871a0a86b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clause </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns any data that was stored in the specified clause. This is useful for modifying any internal part of the query and it is used by the SQL dialects to transform the query accordingly before it is executed. The valid clauses that can be retrieved are: delete, update, set, insert, values, select, distinct, from, join, set, where, group, having, order, limit, offset and union.</p>
<p>The return value for each of those parts may vary. Some clauses use QueryExpression to internally store their state, some use arrays and others may use booleans or integers. This is summary of the return types for each clause.</p>
<ul>
<li>update: string The name of the table to update</li>
<li>set: QueryExpression</li>
<li>insert: array, will return an array containing the table + columns.</li>
<li>values: ValuesExpression</li>
<li>select: array, will return empty array when no fields are set</li>
<li>distinct: boolean</li>
<li>from: array of tables</li>
<li>join: array</li>
<li>set: array</li>
<li>where: QueryExpression, returns null when not set</li>
<li>group: array</li>
<li>having: QueryExpression, returns null when not set</li>
<li>order: OrderByExpression, returns null when not set</li>
<li>limit: integer or QueryExpression, null when not set</li>
<li>offset: integer or QueryExpression, null when not set</li>
<li>union: array</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$name</td><td>name of the clause to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mixed </dd></dl>

</div>
</div>
<a class="anchor" id="ad1d6d1adc19d06409d065db3b9e55892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">connection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$connection</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the connection instance to be used for executing and transforming this query When called with a null argument, it will return the current connection instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">\Cake\Datasource\ConnectionInterface&#160;|&#160;null</td><td class="paramname">$connection</td><td>instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this| </dd></dl>

</div>
</div>
<a class="anchor" id="a91e9fb73d6c774a2ea7f7b756a46bb23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decorateResults </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback to be executed for each result that is fetched from the result set, the callback function will receive as first parameter an array with the raw data from the database for every row that is fetched and must return the row with any possible modifications.</p>
<p>Callbacks will be executed lazily, if only 3 rows are fetched for database it will called 3 times, event though there might be more rows to be fetched in the cursor.</p>
<p>Callbacks are stacked in the order they are registered, if you wish to reset the stack the call this function with the second parameter set to true.</p>
<p>If you wish to remove all decorators from the stack, set the first parameter to null and the second to true.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">$query-&gt;decorateResults(<span class="keyword">function</span> ($row) {</div><div class="line">  $row[<span class="stringliteral">&#39;order_total&#39;</span>] = $row[<span class="stringliteral">&#39;subtotal&#39;</span>] + ($row[<span class="stringliteral">&#39;subtotal&#39;</span>] * $row[<span class="stringliteral">&#39;tax&#39;</span>]);</div><div class="line">   <span class="keywordflow">return</span> $row;</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;null</td><td class="paramname">$callback</td><td>The callback to invoke when results are fetched. </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>Whether or not this should append or replace all existing decorators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a88ba2dace0c829f76af7ea7e4a4bb20e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">delete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$table</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a delete query.</p>
<p>Can be combined with <a class="el" href="class_cake_1_1_database_1_1_query.html#a9b50b832a6e23bdd80c8feb766fc0475">from()</a>, <a class="el" href="class_cake_1_1_database_1_1_query.html#a5dad41b370250166fa451de4210f0654">where()</a> and other methods to create delete queries with specific conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;null</td><td class="paramname">$table</td><td>The table to use when deleting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a8fa95fca61cada5f4c2b5927392d7738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">distinct </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$on</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a DISTINCT clause to the query to remove duplicates from the result set. This clause can only be used for select statements.</p>
<p>If you wish to filter duplicates based of those rows sharing a particular field or set of fields, you may pass an array of fields to filter on. Beware that this option might not be fully supported in all database systems.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line"><span class="comment">// Filters products with the same name and city</span></div><div class="line">$query-&gt;select([<span class="stringliteral">&#39;name&#39;</span>, <span class="stringliteral">&#39;city&#39;</span>])-&gt;from(<span class="stringliteral">&#39;products&#39;</span>)-&gt;distinct();</div><div class="line"></div><div class="line"><span class="comment">// Filters products in the same city</span></div><div class="line">$query-&gt;distinct([<span class="stringliteral">&#39;city&#39;</span>]);</div><div class="line">$query-&gt;distinct(<span class="stringliteral">&#39;city&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Filter products with the same name</span></div><div class="line">$query-&gt;distinct([<span class="stringliteral">&#39;name&#39;</span>], <span class="keyword">true</span>);</div><div class="line">$query-&gt;distinct(<span class="stringliteral">&#39;name&#39;</span>, <span class="keyword">true</span>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;string&#160;|&#160;bool</td><td class="paramname">$on</td><td>Enable/disable distinct class or list of fields to be filtered on </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset fields with passed list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="ae6dfca507dd5223add337a02dfbac59b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">epilog </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$expression</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A string or expression that will be appended to the generated query</p>
<p>### Examples: </p><div class="fragment"><div class="line">$query-&gt;select(<span class="stringliteral">&#39;id&#39;</span>)-&gt;where([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1])-&gt;epilog(<span class="stringliteral">&#39;FOR UPDATE&#39;</span>);</div><div class="line">$query</div><div class="line"> -&gt;insert(<span class="stringliteral">&#39;articles&#39;</span>, [<span class="stringliteral">&#39;title&#39;</span>])</div><div class="line"> -&gt;values([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1])</div><div class="line"> -&gt;epilog(<span class="stringliteral">&#39;RETURNING id&#39;</span>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;\Cake\Database\Expression\QueryExpression&#160;|&#160;null</td><td class="paramname">$expression</td><td>The expression to be appended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a1909f4b7f8129c7790cb75de2ffbe1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">execute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compiles the SQL representation of this query and executes it using the configured connection object. Returns the resulting statement object.</p>
<p>Executing a query internally executes several steps, the first one is letting the connection transform this object to fit its particular dialect, this might result in generating a different <a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a> object that will be the one to actually be executed. Immediately after, literal values are passed to the connection so they are bound to the query in a safe way. Finally, the resulting statement is decorated with custom objects to execute callbacks for each row retrieved if necessary.</p>
<p>Resulting statement is traversable, so it can be used in any loop as you would with an array.</p>
<p>This method can be overridden in query subclasses to decorate behavior around query execution.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a9b50b832a6e23bdd80c8feb766fc0475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">from </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$tables</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single or multiple tables to be used in the FROM clause for this query. Tables can be passed as an array of strings, array of expression objects, a single expression or a single string.</p>
<p>If an array is passed, keys will be used to alias tables using the value as the real field to be aliased. It is possible to alias strings, <a class="el" href="interface_cake_1_1_database_1_1_expression_interface.html">ExpressionInterface</a> objects or even other <a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a> objects.</p>
<p>By default this function will append any passed argument to the list of tables to be selected from, unless the second argument is set to true.</p>
<p>This method can be used for select, update and delete statements.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line">$query-&gt;from([<span class="charliteral">&#39;p&#39;</span> =&gt; <span class="stringliteral">&#39;posts&#39;</span>]); <span class="comment">// Produces FROM posts p</span></div><div class="line">$query-&gt;from(<span class="stringliteral">&#39;authors&#39;</span>); <span class="comment">// Appends authors: FROM posts p, authors</span></div><div class="line">$query-&gt;from([<span class="stringliteral">&#39;products&#39;</span>], <span class="keyword">true</span>); <span class="comment">// Resets the list: FROM products</span></div><div class="line">$query-&gt;from([<span class="stringliteral">&#39;sub&#39;</span> =&gt; $countQuery]); <span class="comment">// FROM (SELECT ...) sub</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;string</td><td class="paramname">$tables</td><td>tables to be added to the list. This argument, can be passed as an array of strings, array of expression objects, or a single string. See the examples above for the valid call types. </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset tables with passed list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a17c6e659a89c18fa9459ec5341063fb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a functions builder object that can be used for generating arbitrary SQL functions.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$query-&gt;func()-&gt;count(<span class="charliteral">&#39;*&#39;</span>);</div><div class="line">$query-&gt;func()-&gt;dateDiff([<span class="stringliteral">&#39;2012-01-05&#39;</span>, <span class="stringliteral">&#39;2012-01-02&#39;</span>])</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7a9f937c2958e6f4dd7b030f86fb70b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">getIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes this query and returns a results iterator. This function is required for implementing the IteratorAggregate interface and allows the query to be iterated without having to call <a class="el" href="class_cake_1_1_database_1_1_query.html#a1909f4b7f8129c7790cb75de2ffbe1e4">execute()</a> manually, thus making it look like a result set instead of the query itself.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af5b89d7b9386040fe8e01d86b1f3ac09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single or multiple fields to be used in the GROUP BY clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p>
<p>By default this function will append any passed argument to the list of fields to be grouped, unless the second argument is set to true.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line"><span class="comment">// Produces GROUP BY id, title</span></div><div class="line">$query-&gt;group([<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;title&#39;</span>]);</div><div class="line"></div><div class="line"><span class="comment">// Produces GROUP BY title</span></div><div class="line">$query-&gt;group(<span class="stringliteral">&#39;title&#39;</span>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;string</td><td class="paramname">$fields</td><td>fields to be added to the list </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset fields with passed list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="ab7d33357f7c7174dc3ff20ff7f84fa3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">having </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a condition or set of conditions to be used in the HAVING clause for this query. This method operates in exactly the same way as the method <code><a class="el" href="class_cake_1_1_database_1_1_query.html#a5dad41b370250166fa451de4210f0654">where()</a></code> does. Please refer to its documentation for an insight on how to using each parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;callable&#160;|&#160;null</td><td class="paramname">$conditions</td><td>The having conditions. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset conditions with passed list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>::where() </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="aef53c3c7f975a98f99c6e94669cfec75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">innerJoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single INNER JOIN clause to the query.</p>
<p>This is a shorthand method for building joins via <code><a class="el" href="class_cake_1_1_database_1_1_query.html#aaabf00d3fd2bf13bd4ce64d54d52e0f3">join()</a></code>.</p>
<p>The arguments of this method are identical to the <code><a class="el" href="class_cake_1_1_database_1_1_query.html#adc1419bc90aa65fc4566c9437ec0a561">leftJoin()</a></code> shorthand, please refer to that methods description for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array</td><td class="paramname">$table</td><td>The table to join with </td></tr>
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface</td><td class="paramname">$conditions</td><td>The conditions to use for joining. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>a list of types associated to the conditions used for converting values to the corresponding database representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="aaa152062d7d481d7cdf981a5f38fccf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">insert </td>
          <td>(</td>
          <td class="paramtype">array&#160;</td>
          <td class="paramname"><em>$columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an insert query.</p>
<p>Note calling this method will reset any data previously set with <a class="el" href="class_cake_1_1_database_1_1_query.html#a8f52cc4c6e1c23a1df054bede131cc40">Query::values()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array</td><td class="paramname">$columns</td><td>The columns to insert into. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>A map between columns &amp; their datatypes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ec3db58cf117fdf7ede0edf4d2c23b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">into </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the table name for insert queries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$table</td><td>The table name to insert into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="aaabf00d3fd2bf13bd4ce64d54d52e0f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$tables</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single or multiple tables to be used as JOIN clauses to this query. Tables can be passed as an array of strings, an array describing the join parts, an array with multiple join descriptions, or a single string.</p>
<p>By default this function will append any passed argument to the list of tables to be joined, unless the third argument is set to true.</p>
<p>When no join type is specified an INNER JOIN is used by default: `$query-&gt;join(['authors'])<code>will produce</code>INNER JOIN authors ON 1 = 1`</p>
<p>It is also possible to alias joins using the array key: `$query-&gt;join(['a' =&gt; 'authors'])`<code>will produce</code>INNER JOIN authors a ON 1 = 1`</p>
<p>A join can be fully described and aliased using the array notation:</p>
<div class="fragment"><div class="line">$query-&gt;join([</div><div class="line">    <span class="charliteral">&#39;a&#39;</span> =&gt; [</div><div class="line">        <span class="stringliteral">&#39;table&#39;</span> =&gt; <span class="stringliteral">&#39;authors&#39;</span>,</div><div class="line">        <span class="stringliteral">&#39;type&#39;</span> =&gt; <span class="stringliteral">&#39;LEFT&#39;</span>,</div><div class="line">        <span class="stringliteral">&#39;conditions&#39;</span> =&gt; <span class="stringliteral">&#39;a.id = b.author_id&#39;</span></div><div class="line">    ]</div><div class="line">]);</div><div class="line"><span class="comment">// Produces LEFT JOIN authors a ON a.id = b.author_id</span></div></div><!-- fragment --><p>You can even specify multiple joins in an array, including the full description:</p>
<div class="fragment"><div class="line">$query-&gt;join([</div><div class="line">    <span class="charliteral">&#39;a&#39;</span> =&gt; [</div><div class="line">        <span class="stringliteral">&#39;table&#39;</span> =&gt; <span class="stringliteral">&#39;authors&#39;</span>,</div><div class="line">        <span class="stringliteral">&#39;type&#39;</span> =&gt; <span class="stringliteral">&#39;LEFT&#39;</span>,</div><div class="line">        <span class="stringliteral">&#39;conditions&#39;</span> =&gt; <span class="stringliteral">&#39;a.id = b.author_id&#39;</span></div><div class="line">    ],</div><div class="line">    <span class="charliteral">&#39;p&#39;</span> =&gt; [</div><div class="line">        <span class="stringliteral">&#39;table&#39;</span> =&gt; <span class="stringliteral">&#39;publishers&#39;</span>,</div><div class="line">        <span class="stringliteral">&#39;type&#39;</span> =&gt; <span class="stringliteral">&#39;INNER&#39;</span>,</div><div class="line">        <span class="stringliteral">&#39;conditions&#39;</span> =&gt; <span class="stringliteral">&#39;p.id = b.publisher_id AND p.name = &quot;Cake Software Foundation&quot;&#39;</span></div><div class="line">    ]</div><div class="line">]);</div><div class="line"><span class="comment">// LEFT JOIN authors a ON a.id = b.author_id</span></div><div class="line"><span class="comment">// INNER JOIN publishers p ON p.id = b.publisher_id AND p.name = &quot;Cake Software Foundation&quot;</span></div></div><!-- fragment --><h3>Using conditions and types</h3>
<p>Conditions can be expressed, as in the examples above, using a string for comparing columns, or string with already quoted literal values. Additionally it is possible to use conditions expressed in arrays or expression objects.</p>
<p>When using arrays for expressing conditions, it is often desirable to convert the literal values to the correct database representation. This is achieved using the second parameter of this function.</p>
<div class="fragment"><div class="line">$query-&gt;join([<span class="charliteral">&#39;a&#39;</span> =&gt; [</div><div class="line">    <span class="stringliteral">&#39;table&#39;</span> =&gt; <span class="stringliteral">&#39;articles&#39;</span>,</div><div class="line">    <span class="stringliteral">&#39;conditions&#39;</span> =&gt; [</div><div class="line">        <span class="stringliteral">&#39;a.posted &gt;=&#39;</span> =&gt; <span class="keyword">new</span> <a class="code" href="namespace_date_time.html">DateTime</a>(<span class="stringliteral">&#39;-3 days&#39;</span>),</div><div class="line">        <span class="stringliteral">&#39;a.published&#39;</span> =&gt; <span class="keyword">true</span>,</div><div class="line">        <span class="stringliteral">&#39;a.author_id = authors.id&#39;</span></div><div class="line">    ]</div><div class="line">]], [<span class="stringliteral">&#39;a.posted&#39;</span> =&gt; <span class="stringliteral">&#39;datetime&#39;</span>, <span class="stringliteral">&#39;a.published&#39;</span> =&gt; <span class="stringliteral">&#39;boolean&#39;</span>])</div></div><!-- fragment --><h3>Overwriting joins</h3>
<p>When creating aliased joins using the array notation, you can override previous join definitions by using the same alias in consequent calls to this function or you can replace all previously defined joins with another list if the third parameter for this function is set to true.</p>
<div class="fragment"><div class="line">$query-&gt;join([<span class="stringliteral">&#39;alias&#39;</span> =&gt; <span class="stringliteral">&#39;table&#39;</span>]); <span class="comment">// joins table with as alias</span></div><div class="line">$query-&gt;join([<span class="stringliteral">&#39;alias&#39;</span> =&gt; <span class="stringliteral">&#39;another_table&#39;</span>]); <span class="comment">// joins another_table with as alias</span></div><div class="line">$query-&gt;join([<span class="stringliteral">&#39;something&#39;</span> =&gt; <span class="stringliteral">&#39;different_table&#39;</span>], [], <span class="keyword">true</span>); <span class="comment">// resets joins list</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;string&#160;|&#160;null</td><td class="paramname">$tables</td><td>list of tables to be joined in the query </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset joins with passed list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="adc1419bc90aa65fc4566c9437ec0a561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">leftJoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single LEFT JOIN clause to the query.</p>
<p>This is a shorthand method for building joins via <code><a class="el" href="class_cake_1_1_database_1_1_query.html#aaabf00d3fd2bf13bd4ce64d54d52e0f3">join()</a></code>.</p>
<p>The table name can be passed as a string, or as an array in case it needs to be aliased:</p>
<div class="fragment"><div class="line"><span class="comment">// LEFT JOIN authors ON authors.id = posts.author_id</span></div><div class="line">$query-&gt;leftJoin(<span class="stringliteral">&#39;authors&#39;</span>, <span class="stringliteral">&#39;authors.id = posts.author_id&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// LEFT JOIN authors a ON a.id = posts.author_id</span></div><div class="line">$query-&gt;leftJoin([<span class="charliteral">&#39;a&#39;</span> =&gt; <span class="stringliteral">&#39;authors&#39;</span>], <span class="stringliteral">&#39;a.id = posts.author_id&#39;</span>);</div></div><!-- fragment --><p>Conditions can be passed as strings, arrays, or expression objects. When using arrays it is possible to combine them with the <code>$types</code> parameter in order to define how to convert the values:</p>
<div class="fragment"><div class="line">$query-&gt;leftJoin([<span class="charliteral">&#39;a&#39;</span> =&gt; <span class="stringliteral">&#39;articles&#39;</span>], [</div><div class="line">     <span class="stringliteral">&#39;a.posted &gt;=&#39;</span> =&gt; <span class="keyword">new</span> <a class="code" href="namespace_date_time.html">DateTime</a>(<span class="stringliteral">&#39;-3 days&#39;</span>),</div><div class="line">     <span class="stringliteral">&#39;a.published&#39;</span> =&gt; <span class="keyword">true</span>,</div><div class="line">     <span class="stringliteral">&#39;a.author_id = authors.id&#39;</span></div><div class="line">], [<span class="stringliteral">&#39;a.posted&#39;</span> =&gt; <span class="stringliteral">&#39;datetime&#39;</span>, <span class="stringliteral">&#39;a.published&#39;</span> =&gt; <span class="stringliteral">&#39;boolean&#39;</span>]);</div></div><!-- fragment --><p>See <code><a class="el" href="class_cake_1_1_database_1_1_query.html#aaabf00d3fd2bf13bd4ce64d54d52e0f3">join()</a></code> for further details on conditions and types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array</td><td class="paramname">$table</td><td>The table to join with </td></tr>
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface</td><td class="paramname">$conditions</td><td>The conditions to use for joining. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>a list of types associated to the conditions used for converting values to the corresponding database representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="aa5fc5a54a6dc7a2b90e12bd7f11e04d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">limit </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of records that should be retrieved from database, accepts an integer or an expression object that evaluates to an integer. In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line">$query-&gt;limit(10) <span class="comment">// generates LIMIT 10</span></div><div class="line">$query-&gt;limit($query-&gt;newExpr()-&gt;add([<span class="stringliteral">&#39;1 + 1&#39;</span>])); <span class="comment">// LIMIT (1 + 1)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int&#160;|&#160;\Cake\Database\ExpressionInterface</td><td class="paramname">$num</td><td>number of records to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a7a3e2d4e2e65ad667955b49ef623d57e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">modifier </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$modifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single or multiple SELECT modifiers to be used in the SELECT.</p>
<p>By default this function will append any passed argument to the list of modifiers to be applied, unless the second argument is set to true.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line"><span class="comment">// Ignore cache query in MySQL</span></div><div class="line">$query-&gt;select([<span class="stringliteral">&#39;name&#39;</span>, <span class="stringliteral">&#39;city&#39;</span>])-&gt;from(<span class="stringliteral">&#39;products&#39;</span>)-&gt;modifier(<span class="stringliteral">&#39;SQL_NO_CACHE&#39;</span>);</div><div class="line"><span class="comment">// It will produce the SQL: SELECT SQL_NO_CACHE name, city FROM products</span></div><div class="line"></div><div class="line"><span class="comment">// Or with multiple modifiers</span></div><div class="line">$query-&gt;select([<span class="stringliteral">&#39;name&#39;</span>, <span class="stringliteral">&#39;city&#39;</span>])-&gt;from(<span class="stringliteral">&#39;products&#39;</span>)-&gt;modifier([<span class="stringliteral">&#39;HIGH_PRIORITY&#39;</span>, <span class="stringliteral">&#39;SQL_NO_CACHE&#39;</span>]);</div><div class="line"><span class="comment">// It will produce the SQL: SELECT HIGH_PRIORITY SQL_NO_CACHE name, city FROM products</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;string</td><td class="paramname">$modifiers</td><td>modifiers to be applied to the query </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset order with field list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a38188a04a8fef17a2d9ef8111fc71910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">newExpr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$rawExpression</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new QueryExpression object. This is a handy function when building complex queries using a fluent interface. You can also override this function in subclasses to use a more specialized QueryExpression class if required.</p>
<p>You can optionally pass a single raw SQL string or an array or expressions in any format accepted by :</p>
<div class="fragment"><div class="line">$expression = $query-&gt;newExpr(); <span class="comment">// Returns an empty expression object</span></div><div class="line">$expression = $query-&gt;newExpr(<span class="stringliteral">&#39;Table.column = Table2.column&#39;</span>); <span class="comment">// Return a raw SQL expression</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">mixed</td><td class="paramname">$rawExpression</td><td>A string, array or anything you want wrapped in an expression object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a31dadf1bda69ff9adbf83c83a5e77345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">offset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of records that should be skipped from the original result set This is commonly used for paginating large results. Accepts an integer or an expression object that evaluates to an integer.</p>
<p>In some databases, this operation might not be supported or will require the query to be transformed in order to limit the result set size.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line">$query-&gt;offset(10) <span class="comment">// generates OFFSET 10</span></div><div class="line">$query-&gt;offset($query-&gt;newExpr()-&gt;add([<span class="stringliteral">&#39;1 + 1&#39;</span>])); <span class="comment">// OFFSET (1 + 1)</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int&#160;|&#160;\Cake\Database\ExpressionInterface</td><td class="paramname">$num</td><td>number of records to be skipped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="ad1bf3a780d938bcd45aa9913ec4c645e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single or multiple fields to be used in the ORDER clause for this query. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p>
<p>If an array is passed, keys will be used as the field itself and the value will represent the order in which such field should be ordered. When called multiple times with the same fields as key, the last order definition will prevail over the others.</p>
<p>By default this function will append any passed argument to the list of fields to be selected, unless the second argument is set to true.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line">$query-&gt;order([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;DESC&#39;</span>, <span class="stringliteral">&#39;author_id&#39;</span> =&gt; <span class="stringliteral">&#39;ASC&#39;</span>]);</div></div><!-- fragment --><p>Produces:</p>
<p><code>ORDER BY title DESC, author_id ASC</code></p>
<div class="fragment"><div class="line">$query-&gt;order([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;DESC NULLS FIRST&#39;</span>])-&gt;order(<span class="stringliteral">&#39;author_id&#39;</span>);</div></div><!-- fragment --><p>Will generate:</p>
<p><code>ORDER BY title DESC NULLS FIRST, author_id</code></p>
<div class="fragment"><div class="line">$expression = $query-&gt;newExpr()-&gt;add([<span class="stringliteral">&#39;id % 2 = 0&#39;</span>]);</div><div class="line">$query-&gt;order($expression)-&gt;order([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;ASC&#39;</span>]);</div></div><!-- fragment --><p>Will become:</p>
<p><code>ORDER BY (id %2 = 0), title ASC</code></p>
<p>If you need to set complex expressions as order conditions, you should use <code><a class="el" href="class_cake_1_1_database_1_1_query.html#ab3af23d370e24a90397a4aba1093e952">orderAsc()</a></code> or <code><a class="el" href="class_cake_1_1_database_1_1_query.html#a860119509d9f8e4ad15014c3332b3f1b">orderDesc()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;string</td><td class="paramname">$fields</td><td>fields to be added to the list </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset order with field list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="ab3af23d370e24a90397a4aba1093e952"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">orderAsc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an ORDER BY clause with an ASC direction.</p>
<p>This method allows you to set complex expressions as order conditions unlike <a class="el" href="class_cake_1_1_database_1_1_query.html#ad1bf3a780d938bcd45aa9913ec4c645e">order()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;\Cake\Database\Expression\QueryExpression</td><td class="paramname">$field</td><td>The field to order on. </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>Whether or not to reset the order clauses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a860119509d9f8e4ad15014c3332b3f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">orderDesc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an ORDER BY clause with a DESC direction.</p>
<p>This method allows you to set complex expressions as order conditions unlike <a class="el" href="class_cake_1_1_database_1_1_query.html#ad1bf3a780d938bcd45aa9913ec4c645e">order()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;\Cake\Database\Expression\QueryExpression</td><td class="paramname">$field</td><td>The field to order on. </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>Whether or not to reset the order clauses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="affe481cb16a86300021b5396368ced4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">orHaving </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects any previously defined set of conditions to the provided list using the OR operator in the HAVING clause. This method operates in exactly the same way as the method <code><a class="el" href="class_cake_1_1_database_1_1_query.html#a42526c0e77be52c51f583780cb9b69ac">orWhere()</a></code> does. Please refer to its documentation for an insight on how to using each parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;callable</td><td class="paramname">$conditions</td><td>The OR conditions for HAVING. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>::orWhere() </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a42526c0e77be52c51f583780cb9b69ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">orWhere </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connects any previously defined set of conditions to the provided list using the OR operator. This function accepts the conditions list in the same format as the method <code>where</code> does, hence you can use arrays, expression objects callback functions or strings.</p>
<p>It is important to notice that when calling this function, any previous set of conditions defined for this query will be treated as a single argument for the OR operator. This function will not only operate the most recently defined condition, but all the conditions as a whole.</p>
<p>When using an array for defining conditions, creating constraints form each array entry will use the same logic as with the <code><a class="el" href="class_cake_1_1_database_1_1_query.html#a5dad41b370250166fa451de4210f0654">where()</a></code> function. This means that each array entry will be joined to the other using the OR operator, unless you nest the conditions in the array using other operator.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line">$query-&gt;where([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;Hello World&#39;</span>)-&gt;orWhere([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;Foo&#39;</span>]);</div></div><!-- fragment --><p>Will produce:</p>
<p>`WHERE title = 'Hello World' OR title = 'Foo'`</p>
<div class="fragment"><div class="line">$query</div><div class="line">  -&gt;where([<span class="stringliteral">&#39;OR&#39;</span> =&gt; [<span class="stringliteral">&#39;published&#39;</span> =&gt; <span class="keyword">false</span>, <span class="stringliteral">&#39;published is NULL&#39;</span>]])</div><div class="line">  -&gt;orWhere([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;comments_count &gt;&#39;</span> =&gt; 10])</div></div><!-- fragment --><p>Produces:</p>
<p><code>WHERE (published = 0 OR published IS NULL) OR (author_id = 1 AND comments_count &gt; 10)</code></p>
<div class="fragment"><div class="line">$query</div><div class="line">  -&gt;where([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;Foo&#39;</span>])</div><div class="line">  -&gt;orWhere(<span class="keyword">function</span> ($exp, $query) {</div><div class="line">    <span class="keywordflow">return</span> $exp</div><div class="line">      -&gt;add([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1])</div><div class="line">      -&gt;or_([<span class="stringliteral">&#39;author_id&#39;</span> =&gt; 2]);</div><div class="line">  });</div></div><!-- fragment --><p>Generates the following conditions:</p>
<p>`WHERE (title = 'Foo') OR (author_id = 1 OR author_id = 2)`</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;callable</td><td class="paramname">$conditions</td><td>The conditions to add with OR. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>::where() </dd>
<dd>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="abe84bfa523332fc6735754f94bfe7538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">page </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$limit</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the page of results you want.</p>
<p>This method provides an easier to use interface to set the limit + offset in the record set you want as results. If empty the limit will default to the existing limit clause, and if that too is empty, then <code>25</code> will be used.</p>
<p>Pages should start at 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$num</td><td>The page number you want. </td></tr>
    <tr><td class="paramtype">int&#160;|&#160;null</td><td class="paramname">$limit</td><td>The number of rows you want in the page. If null the current limit clause will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="ab8ee60532a19ce2ecfbe140b3e6121b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">removeJoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a join if it has been defined.</p>
<p>Useful when you are redefining joins or want to re-order the join clauses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$name</td><td>The alias/name of the join to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a39f6d928a297d2d453041ed014e5ff99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rightJoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single RIGHT JOIN clause to the query.</p>
<p>This is a shorthand method for building joins via <code><a class="el" href="class_cake_1_1_database_1_1_query.html#aaabf00d3fd2bf13bd4ce64d54d52e0f3">join()</a></code>.</p>
<p>The arguments of this method are identical to the <code><a class="el" href="class_cake_1_1_database_1_1_query.html#adc1419bc90aa65fc4566c9437ec0a561">leftJoin()</a></code> shorthand, please refer to that methods description for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array</td><td class="paramname">$table</td><td>The table to join with </td></tr>
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface</td><td class="paramname">$conditions</td><td>The conditions to use for joining. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>a list of types associated to the conditions used for converting values to the corresponding database representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a3fbf6be7aea0c748e41c583d9cd3add2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">select </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$fields</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds new fields to be returned by a SELECT statement when this query is executed. Fields can be passed as an array of strings, array of expression objects, a single expression or a single string.</p>
<p>If an array is passed, keys will be used to alias fields using the value as the real field to be aliased. It is possible to alias strings, <a class="el" href="namespace_cake_1_1_database_1_1_expression.html">Expression</a> objects or even other <a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a> objects.</p>
<p>If a callable function is passed, the returning array of the function will be used as the list of fields.</p>
<p>By default this function will append any passed argument to the list of fields to be selected, unless the second argument is set to true.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line">$query-&gt;select([<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;title&#39;</span>]); <span class="comment">// Produces SELECT id, title</span></div><div class="line">$query-&gt;select([<span class="stringliteral">&#39;author&#39;</span> =&gt; <span class="stringliteral">&#39;author_id&#39;</span>]); <span class="comment">// Appends author: SELECT id, title, author_id as author</span></div><div class="line">$query-&gt;select(<span class="stringliteral">&#39;id&#39;</span>, <span class="keyword">true</span>); <span class="comment">// Resets the list: SELECT id</span></div><div class="line">$query-&gt;select([<span class="stringliteral">&#39;total&#39;</span> =&gt; $countQuery]); <span class="comment">// SELECT id, (SELECT ...) AS total</span></div><div class="line">$query-&gt;select(<span class="keyword">function</span> ($query) {</div><div class="line">    <span class="keywordflow">return</span> [<span class="stringliteral">&#39;article_id&#39;</span>, <span class="stringliteral">&#39;total&#39;</span> =&gt; $query-&gt;count(<span class="charliteral">&#39;*&#39;</span>)];</div><div class="line">})</div></div><!-- fragment --><p>By default no fields are selected, if you have an instance of <code><a class="el" href="namespace_cake.html">Cake</a>\<a class="el" href="namespace_cake_1_1_o_r_m.html">ORM</a>\<a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a></code> and try to append fields you should also call <code><a class="el" href="namespace_cake.html">Cake</a>\<a class="el" href="namespace_cake_1_1_o_r_m.html">ORM</a>\Query::autoFields()</code> to select the default fields from the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;string&#160;|&#160;callable</td><td class="paramname">$fields</td><td>fields to be added to the list. </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset fields with passed list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a43183897a77655d4b11f3f099d4bb988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">selectTypeMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cake_1_1_database_1_1_type_map.html">TypeMap</a>&#160;</td>
          <td class="paramname"><em>$typeMap</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the <a class="el" href="class_cake_1_1_database_1_1_type_map.html">TypeMap</a> class where the types for each of the fields in the select clause are stored.</p>
<p>When called with no arguments, the current <a class="el" href="class_cake_1_1_database_1_1_type_map.html">TypeMap</a> object is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">\Cake\Database\TypeMap&#160;|&#160;null</td><td class="paramname">$typeMap</td><td>The map object to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this| </dd></dl>

</div>
</div>
<a class="anchor" id="a13b2d42a061fd6bbd461fdd9d5f1e41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$value</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set one or many fields to update.</p>
<h3>Examples</h3>
<p>Passing a string:</p>
<div class="fragment"><div class="line">$query-&gt;update(<span class="stringliteral">&#39;articles&#39;</span>)-&gt;set(<span class="stringliteral">&#39;title&#39;</span>, <span class="stringliteral">&#39;The Title&#39;</span>);</div></div><!-- fragment --><p>Passing an array:</p>
<div class="fragment"><div class="line">$query-&gt;update(<span class="stringliteral">&#39;articles&#39;</span>)-&gt;set([<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;The Title&#39;</span>], [<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;string&#39;</span>]);</div></div><!-- fragment --><p>Passing a callable:</p>
<div class="fragment"><div class="line">$query-&gt;update(<span class="stringliteral">&#39;articles&#39;</span>)-&gt;set(<span class="keyword">function</span> ($exp) {</div><div class="line">  <span class="keywordflow">return</span> $exp-&gt;eq(<span class="stringliteral">&#39;title&#39;</span>, <span class="stringliteral">&#39;The title&#39;</span>, <span class="stringliteral">&#39;string&#39;</span>);</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;callable&#160;|&#160;\Cake\Database\Expression\QueryExpression</td><td class="paramname">$key</td><td>The column name or array of keys<ul>
<li>values to set. This can also be a QueryExpression containing a SQL fragment. It can also be a callable, that is required to return an expression object. </li>
</ul>
</td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$value</td><td>The value to update $key to. Can be null if $key is an array or QueryExpression. When $key is an array, this parameter will be used as $types instead. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>The column types to treat data as. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="ad453d5675564710643f65cec433429cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cake_1_1_database_1_1_value_binder.html">ValueBinder</a>&#160;</td>
          <td class="paramname"><em>$generator</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the SQL representation of this object.</p>
<p>This function will compile this query to make it compatible with the SQL dialect that is used by the connection, This process might add, remove or alter any query part or internal expression to make it executable in the target platform.</p>
<p>The resulting query may have placeholders that will be replaced with the actual values when the query is executed, hence it is most suitable to use with prepared statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">\Cake\Database\ValueBinder&#160;|&#160;null</td><td class="paramname">$generator</td><td>A placeholder object that will hold associated values for expressions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

<p>Implements <a class="el" href="interface_cake_1_1_database_1_1_expression_interface.html#a74e709967db8a1bd259de5d42ead4790">ExpressionInterface</a>.</p>

</div>
</div>
<a class="anchor" id="afb0fdf35270d29a9c4ade9ed8981bce6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">traverse </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&#160;</td>
          <td class="paramname"><em>$parts</em> = <code>[]</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will iterate over every specified part. Traversing functions can aggregate results using variables in the closure or instance variables. This function is commonly used as a way for traversing all query parts that are going to be used for constructing a query.</p>
<p>The callback will receive 2 parameters, the first one is the value of the query part that is being iterated and the second the name of such part.</p>
<p>### Example: </p><div class="fragment"><div class="line">$query-&gt;select([<span class="stringliteral">&#39;title&#39;</span>])-&gt;from(<span class="stringliteral">&#39;articles&#39;</span>)-&gt;traverse(<span class="keyword">function</span> ($value, $clause) {</div><div class="line">    <span class="keywordflow">if</span> ($clause === <span class="stringliteral">&#39;select&#39;</span>) {</div><div class="line">        var_dump($value);</div><div class="line">    }</div><div class="line">}, [<span class="stringliteral">&#39;select&#39;</span>, <span class="stringliteral">&#39;from&#39;</span>]);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$visitor</td><td>A function or callable to be executed for each part </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$parts</td><td>The query clauses to traverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a0cfc9c3a767a8ae6a65e7ab44ec55650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">traverseExpressions </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function works similar to the <a class="el" href="class_cake_1_1_database_1_1_query.html#afb0fdf35270d29a9c4ade9ed8981bce6">traverse()</a> function, with the difference that it does a full depth traversal of the entire expression tree. This will execute the provided callback function for each <a class="el" href="interface_cake_1_1_database_1_1_expression_interface.html">ExpressionInterface</a> object that is stored inside this query at any nesting depth in any part of the query.</p>
<p>Callback will receive as first parameter the currently visited expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$callback</td><td>the function to be executed for each <a class="el" href="interface_cake_1_1_database_1_1_expression_interface.html">ExpressionInterface</a> found inside this query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this|null </dd></dl>

</div>
</div>
<a class="anchor" id="adb1e1faec5bf612c1ffc08f75907ec18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of this query (select, insert, update, delete)</p>
<dl class="section return"><dt>Returns</dt><dd>string </dd></dl>

</div>
</div>
<a class="anchor" id="a817b2cf9717700a58bf428bf4a5ed3be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a complete query to be used in conjunction with an UNION operator with this query. This is used to combine the result set of this query with the one that will be returned by the passed query. You can add as many queries as you required by calling multiple times this method with different queries.</p>
<p>By default, the UNION operator will remove duplicate rows, if you wish to include every row for all queries, use <a class="el" href="class_cake_1_1_database_1_1_query.html#afb352d987588edfca755a6cb565921a9">unionAll()</a>.</p>
<h3>Examples</h3>
<div class="fragment"><div class="line">$union = (<span class="keyword">new</span> Query($conn))-&gt;<a class="code" href="class_cake_1_1_database_1_1_query.html#a3fbf6be7aea0c748e41c583d9cd3add2">select</a>([<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;title&#39;</span>])-&gt;from([<span class="charliteral">&#39;a&#39;</span> =&gt; <span class="stringliteral">&#39;articles&#39;</span>]);</div><div class="line">$query-&gt;select([<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;name&#39;</span>])-&gt;from([<span class="charliteral">&#39;d&#39;</span> =&gt; <span class="stringliteral">&#39;things&#39;</span>])-&gt;union($union);</div></div><!-- fragment --><p>Will produce:</p>
<p><code>SELECT id, name FROM things d UNION SELECT id, title FROM articles a</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;\Cake\Database\Query</td><td class="paramname">$query</td><td>full SQL query to be used in UNION operator </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset the list of queries to be operated or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="afb352d987588edfca755a6cb565921a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unionAll </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a complete query to be used in conjunction with the UNION ALL operator with this query. This is used to combine the result set of this query with the one that will be returned by the passed query. You can add as many queries as you required by calling multiple times this method with different queries.</p>
<p>Unlike UNION, UNION ALL will not remove duplicate rows.</p>
<div class="fragment"><div class="line">$union = (<span class="keyword">new</span> Query($conn))-&gt;<a class="code" href="class_cake_1_1_database_1_1_query.html#a3fbf6be7aea0c748e41c583d9cd3add2">select</a>([<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;title&#39;</span>])-&gt;from([<span class="charliteral">&#39;a&#39;</span> =&gt; <span class="stringliteral">&#39;articles&#39;</span>]);</div><div class="line">$query-&gt;select([<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;name&#39;</span>])-&gt;from([<span class="charliteral">&#39;d&#39;</span> =&gt; <span class="stringliteral">&#39;things&#39;</span>])-&gt;unionAll($union);</div></div><!-- fragment --><p>Will produce:</p>
<p><code>SELECT id, name FROM things d UNION ALL SELECT id, title FROM articles a</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;\Cake\Database\Query</td><td class="paramname">$query</td><td>full SQL query to be used in UNION operator </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset the list of queries to be operated or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="a76f182bf26b338c017aad8c38aad4055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">update </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an update query.</p>
<p>Can be combined with <a class="el" href="class_cake_1_1_database_1_1_query.html#a13b2d42a061fd6bbd461fdd9d5f1e41a">set()</a> and <a class="el" href="class_cake_1_1_database_1_1_query.html#a5dad41b370250166fa451de4210f0654">where()</a> methods to create update queries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$table</td><td>The table you want to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<a class="anchor" id="acd5c318570ef055323cb9695e7613b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">valueBinder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$binder</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the currently used <a class="el" href="class_cake_1_1_database_1_1_value_binder.html">ValueBinder</a> instance. If a value is passed, it will be set as the new instance to be used.</p>
<p>A <a class="el" href="class_cake_1_1_database_1_1_value_binder.html">ValueBinder</a> is responsible for generating query placeholders and temporarily associate values to those placeholders so that they can be passed correctly statement object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">\Cake\Database\ValueBinder&#160;|&#160;null</td><td class="paramname">$binder</td><td>new instance to be set. If no value is passed the default one will be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this| </dd></dl>

</div>
</div>
<a class="anchor" id="a8f52cc4c6e1c23a1df054bede131cc40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the values for an insert query.</p>
<p>Multi inserts can be performed by calling <a class="el" href="class_cake_1_1_database_1_1_query.html#a8f52cc4c6e1c23a1df054bede131cc40">values()</a> more than one time, or by providing an array of value sets. Additionally $data can be a <a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a> instance to insert data from another SELECT statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;\Cake\Database\Query</td><td class="paramname">$data</td><td>The data to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dad41b370250166fa451de4210f0654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">where </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$conditions</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$types</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a condition or set of conditions to be used in the WHERE clause for this query. Conditions can be expressed as an array of fields as keys with comparison operators in it, the values for the array will be used for comparing the field to such literal. Finally, conditions can be expressed as a single string or an array of strings.</p>
<p>When using arrays, each entry will be joined to the rest of the conditions using an AND operator. Consecutive calls to this function will also join the new conditions specified using the AND operator. Additionally, values can be expressed using expression objects which can include other query objects.</p>
<p>Any conditions created with this methods can be used with any SELECT, UPDATE and DELETE type of queries.</p>
<h3>Conditions using operators:</h3>
<div class="fragment"><div class="line">$query-&gt;where([</div><div class="line">    <span class="stringliteral">&#39;posted &gt;=&#39;</span> =&gt; <span class="keyword">new</span> <a class="code" href="namespace_date_time.html">DateTime</a>(<span class="stringliteral">&#39;3 days ago&#39;</span>),</div><div class="line">    <span class="stringliteral">&#39;title LIKE&#39;</span> =&gt; <span class="stringliteral">&#39;Hello W%&#39;</span>,</div><div class="line">    <span class="stringliteral">&#39;author_id&#39;</span> =&gt; 1,</div><div class="line">], [<span class="stringliteral">&#39;posted&#39;</span> =&gt; <span class="stringliteral">&#39;datetime&#39;</span>]);</div></div><!-- fragment --><p>The previous example produces:</p>
<p>`WHERE posted &gt;= 2012-01-27 AND title LIKE 'Hello W' AND author_id = 1`</p>
<p>Second parameter is used to specify what type is expected for each passed key. Valid types can be used from the mapped with <a class="el" href="namespace_cake_1_1_database.html">Database</a> class.</p>
<h3>Nesting conditions with conjunctions:</h3>
<div class="fragment"><div class="line">$query-&gt;where([</div><div class="line">    <span class="stringliteral">&#39;author_id !=&#39;</span> =&gt; 1,</div><div class="line">    <span class="stringliteral">&#39;OR&#39;</span> =&gt; [<span class="stringliteral">&#39;published&#39;</span> =&gt; <span class="keyword">true</span>, <span class="stringliteral">&#39;posted &lt;&#39;</span> =&gt; <span class="keyword">new</span> <a class="code" href="namespace_date_time.html">DateTime</a>(<span class="stringliteral">&#39;now&#39;</span>)],</div><div class="line">    <span class="stringliteral">&#39;NOT&#39;</span> =&gt; [<span class="stringliteral">&#39;title&#39;</span> =&gt; <span class="stringliteral">&#39;Hello&#39;</span>]</div><div class="line">], [<span class="stringliteral">&#39;published&#39;</span> =&gt; <span class="keywordtype">boolean</span>, <span class="stringliteral">&#39;posted&#39;</span> =&gt; <span class="stringliteral">&#39;datetime&#39;</span>]</div></div><!-- fragment --><p>The previous example produces:</p>
<p>`WHERE author_id = 1 AND (published = 1 OR posted &lt; '2012-02-01') AND NOT (title = 'Hello')`</p>
<p>You can nest conditions using conjunctions as much as you like. Sometimes, you may want to define 2 different options for the same key, in that case, you can wrap each condition inside a new array:</p>
<p>`$query-&gt;where(['OR' =&gt; [['published' =&gt; false], ['published' =&gt; true]])`</p>
<p>Keep in mind that every time you call <a class="el" href="class_cake_1_1_database_1_1_query.html#a5dad41b370250166fa451de4210f0654">where()</a> with the third param set to false (default), it will join the passed conditions to the previous stored list using the AND operator. Also, using the same array key twice in consecutive calls to this method will not override the previous value.</p>
<h3>Using expressions objects:</h3>
<div class="fragment"><div class="line">$exp = $query-&gt;newExpr()-&gt;add([<span class="stringliteral">&#39;id !=&#39;</span> =&gt; 100, <span class="stringliteral">&#39;author_id&#39;</span> != 1])-&gt;tieWith(<span class="stringliteral">&#39;OR&#39;</span>);</div><div class="line">$query-&gt;where([<span class="stringliteral">&#39;published&#39;</span> =&gt; <span class="keyword">true</span>], [<span class="stringliteral">&#39;published&#39;</span> =&gt; <span class="stringliteral">&#39;boolean&#39;</span>])-&gt;where($exp);</div></div><!-- fragment --><p>The previous example produces:</p>
<p><code>WHERE (id != 100 OR author_id != 1) AND published = 1</code></p>
<p>Other <a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a> objects that be used as conditions for any field.</p>
<h3>Adding conditions in multiple steps:</h3>
<p>You can use callable functions to construct complex expressions, functions receive as first argument a new QueryExpression object and this query instance as second argument. Functions must return an expression object, that will be added the list of conditions for the query using the AND operator.</p>
<div class="fragment"><div class="line">$query</div><div class="line">  -&gt;where([<span class="stringliteral">&#39;title !=&#39;</span> =&gt; <span class="stringliteral">&#39;Hello World&#39;</span>])</div><div class="line">  -&gt;where(<span class="keyword">function</span> ($exp, $query) {</div><div class="line">    $or = $exp-&gt;or_([<span class="stringliteral">&#39;id&#39;</span> =&gt; 1]);</div><div class="line">    $and = $exp-&gt;and_([<span class="stringliteral">&#39;id &gt;&#39;</span> =&gt; 2, <span class="stringliteral">&#39;id &lt;&#39;</span> =&gt; 10]);</div><div class="line">   <span class="keywordflow">return</span> $or-&gt;add($and);</div><div class="line">  });</div></div><!-- fragment --><ul>
<li>The previous example produces:</li>
</ul>
<p>`WHERE title != 'Hello World' AND (id = 1 OR (id &gt; 2 AND id &lt; 10))`</p>
<h3>Conditions as strings:</h3>
<div class="fragment"><div class="line">$query-&gt;where([<span class="stringliteral">&#39;articles.author_id = authors.id&#39;</span>, <span class="stringliteral">&#39;modified IS NULL&#39;</span>]);</div></div><!-- fragment --><p>The previous example produces:</p>
<p><code>WHERE articles.author_id = authors.id AND modified IS NULL</code></p>
<p>Please note that when using the array notation or the expression objects, all values will be correctly quoted and transformed to the correspondent database data type automatically for you, thus securing your application from SQL injections. If you use string conditions make sure that your values are correctly quoted. The safest thing you can do is to never use string conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;array&#160;|&#160;\Cake\Database\ExpressionInterface&#160;|&#160;callable&#160;|&#160;null</td><td class="paramname">$conditions</td><td>The conditions to filter on. </td></tr>
    <tr><td class="paramtype">array</td><td class="paramname">$types</td><td>associative array of type names used to bind values to query </td></tr>
    <tr><td class="paramtype">bool</td><td class="paramname">$overwrite</td><td>whether to reset conditions with passed list or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd></dd>
<dd>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>$this </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a475b901300c346a261d1393f62cfb763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">$_parts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [</div><div class="line">        <span class="stringliteral">&#39;delete&#39;</span> =&gt; <span class="keyword">true</span></div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vendor/cakephp/cakephp/src/Database/Query.php</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_cake.html">Cake</a></li><li class="navelem"><a class="el" href="namespace_cake_1_1_database.html">Database</a></li><li class="navelem"><a class="el" href="class_cake_1_1_database_1_1_query.html">Query</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
