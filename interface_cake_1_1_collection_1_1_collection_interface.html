<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Webspa - grupo 4: CollectionInterface Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Webspa - grupo 4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('interface_cake_1_1_collection_1_1_collection_interface.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">CollectionInterface Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for CollectionInterface:</div>
<div class="dyncontent">
<div class="center"><img src="interface_cake_1_1_collection_1_1_collection_interface__inherit__graph.png" border="0" usemap="#_collection_interface_inherit__map" alt="Inheritance graph"/></div>
<map name="_collection_interface_inherit__map" id="_collection_interface_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for CollectionInterface:</div>
<div class="dyncontent">
<div class="center"><img src="interface_cake_1_1_collection_1_1_collection_interface__coll__graph.png" border="0" usemap="#_collection_interface_coll__map" alt="Collaboration graph"/></div>
<map name="_collection_interface_coll__map" id="_collection_interface_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5626b35c368ad61290c795cb20770f94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a5626b35c368ad61290c795cb20770f94">each</a> (callable $c)</td></tr>
<tr class="separator:a5626b35c368ad61290c795cb20770f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171f012cd03fe8f5761637a101c0fa47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a171f012cd03fe8f5761637a101c0fa47">filter</a> (callable $c=null)</td></tr>
<tr class="separator:a171f012cd03fe8f5761637a101c0fa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaef54e202c1bcfec248c3c7acd8de2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#adaef54e202c1bcfec248c3c7acd8de2d">reject</a> (callable $c)</td></tr>
<tr class="separator:adaef54e202c1bcfec248c3c7acd8de2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60fc2a392280304d87c6e7f9de6f28bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a60fc2a392280304d87c6e7f9de6f28bf">every</a> (callable $c)</td></tr>
<tr class="separator:a60fc2a392280304d87c6e7f9de6f28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ecae2c1a0c69f0eef231abf8b4b4ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a96ecae2c1a0c69f0eef231abf8b4b4ed">some</a> (callable $c)</td></tr>
<tr class="separator:a96ecae2c1a0c69f0eef231abf8b4b4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2aea429e66ac043bb00a49bbd9467e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#ade2aea429e66ac043bb00a49bbd9467e">contains</a> ($value)</td></tr>
<tr class="separator:ade2aea429e66ac043bb00a49bbd9467e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12903585bd417382e695a2390ffd626b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a12903585bd417382e695a2390ffd626b">map</a> (callable $c)</td></tr>
<tr class="separator:a12903585bd417382e695a2390ffd626b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae0a549be85abcd70d503a64c3126dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#acae0a549be85abcd70d503a64c3126dd">reduce</a> (callable $c, $zero=null)</td></tr>
<tr class="separator:acae0a549be85abcd70d503a64c3126dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87da587eaaf21fe62c6bcfd3a1e67916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a87da587eaaf21fe62c6bcfd3a1e67916">extract</a> ($matcher)</td></tr>
<tr class="separator:a87da587eaaf21fe62c6bcfd3a1e67916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0938e9829f75c1b1509307883c9f35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#adf0938e9829f75c1b1509307883c9f35">max</a> ($callback, $type=SORT_NUMERIC)</td></tr>
<tr class="separator:adf0938e9829f75c1b1509307883c9f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4777b629ffa559c0cfa11ed02fda1662"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a4777b629ffa559c0cfa11ed02fda1662">min</a> ($callback, $type=SORT_NUMERIC)</td></tr>
<tr class="separator:a4777b629ffa559c0cfa11ed02fda1662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c34e2bd3e1578c8dd19023e97948a1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a2c34e2bd3e1578c8dd19023e97948a1c">sortBy</a> ($callback, $dir=SORT_DESC, $type=SORT_NUMERIC)</td></tr>
<tr class="separator:a2c34e2bd3e1578c8dd19023e97948a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25082bae9e5093235499b59c8712168"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#ab25082bae9e5093235499b59c8712168">groupBy</a> ($callback)</td></tr>
<tr class="separator:ab25082bae9e5093235499b59c8712168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35aa5525146f287686cc010a4aa0927"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#ac35aa5525146f287686cc010a4aa0927">indexBy</a> ($callback)</td></tr>
<tr class="separator:ac35aa5525146f287686cc010a4aa0927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc58f751b824a50403e11f533a49f94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0dc58f751b824a50403e11f533a49f94">countBy</a> ($callback)</td></tr>
<tr class="separator:a0dc58f751b824a50403e11f533a49f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778a968468403f1489fdd07937efaea1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a778a968468403f1489fdd07937efaea1">sumOf</a> ($matcher=null)</td></tr>
<tr class="separator:a778a968468403f1489fdd07937efaea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce59714eca34395b19320a00ca1c7da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#afce59714eca34395b19320a00ca1c7da">shuffle</a> ()</td></tr>
<tr class="separator:afce59714eca34395b19320a00ca1c7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0799a938e9d3e0f777a6d7a24f64977f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0799a938e9d3e0f777a6d7a24f64977f">sample</a> ($size=10)</td></tr>
<tr class="separator:a0799a938e9d3e0f777a6d7a24f64977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9579f823a6c66ac1c968eb6b8a21d23b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a9579f823a6c66ac1c968eb6b8a21d23b">take</a> ($size=1, $from=0)</td></tr>
<tr class="separator:a9579f823a6c66ac1c968eb6b8a21d23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5aee77a2ffc76c05cf670a165fb2a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0b5aee77a2ffc76c05cf670a165fb2a2">skip</a> ($howMany)</td></tr>
<tr class="separator:a0b5aee77a2ffc76c05cf670a165fb2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623727743cb9c3dde4fb86afb61f1f43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a623727743cb9c3dde4fb86afb61f1f43">match</a> (array $conditions)</td></tr>
<tr class="separator:a623727743cb9c3dde4fb86afb61f1f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e850fe1e72606cb9c22de6a3505e225"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a4e850fe1e72606cb9c22de6a3505e225">firstMatch</a> (array $conditions)</td></tr>
<tr class="separator:a4e850fe1e72606cb9c22de6a3505e225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73eef9ff76ea330c0dab36ca448b90d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#ac73eef9ff76ea330c0dab36ca448b90d">first</a> ()</td></tr>
<tr class="separator:ac73eef9ff76ea330c0dab36ca448b90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90cadb327363232bb2d83a4f8ebd613"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#ac90cadb327363232bb2d83a4f8ebd613">last</a> ()</td></tr>
<tr class="separator:ac90cadb327363232bb2d83a4f8ebd613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40356bd2ce6d77017a4761f4d39bb4ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a40356bd2ce6d77017a4761f4d39bb4ac">append</a> ($items)</td></tr>
<tr class="separator:a40356bd2ce6d77017a4761f4d39bb4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0276e393807dc8bed14aa61d40292d1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0276e393807dc8bed14aa61d40292d1e">combine</a> ($keyPath, $valuePath, $groupPath=null)</td></tr>
<tr class="separator:a0276e393807dc8bed14aa61d40292d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840571bac23a95974b848bf3bf5c5012"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a840571bac23a95974b848bf3bf5c5012">nest</a> ($idPath, $parentPath, $nestingKey= 'children')</td></tr>
<tr class="separator:a840571bac23a95974b848bf3bf5c5012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55e55fd4a6f43679523e26747cee1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#abc55e55fd4a6f43679523e26747cee1a">insert</a> ($path, $values)</td></tr>
<tr class="separator:abc55e55fd4a6f43679523e26747cee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d268fad8337f989252cd548a27f7400"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a5d268fad8337f989252cd548a27f7400">toArray</a> ($preserveKeys=true)</td></tr>
<tr class="separator:a5d268fad8337f989252cd548a27f7400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b8e53645e6f61a6e2a9cfe7b56de70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#af7b8e53645e6f61a6e2a9cfe7b56de70">toList</a> ()</td></tr>
<tr class="separator:af7b8e53645e6f61a6e2a9cfe7b56de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402d8679325bc514874370f02b5c2ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#ad402d8679325bc514874370f02b5c2ac">jsonSerialize</a> ()</td></tr>
<tr class="separator:ad402d8679325bc514874370f02b5c2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba51c634aa895fc1cea39d6e0971a765"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#aba51c634aa895fc1cea39d6e0971a765">compile</a> ($preserveKeys=true)</td></tr>
<tr class="separator:aba51c634aa895fc1cea39d6e0971a765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d28b4372c711f1dd84d91d03974e11a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a3d28b4372c711f1dd84d91d03974e11a">buffered</a> ()</td></tr>
<tr class="separator:a3d28b4372c711f1dd84d91d03974e11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9f25f41c3449fd451c3a4516ccb160"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#acd9f25f41c3449fd451c3a4516ccb160">listNested</a> ($dir= 'desc', $nestingKey= 'children')</td></tr>
<tr class="separator:acd9f25f41c3449fd451c3a4516ccb160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef453a53e675458a35bc62b311c2d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#aaef453a53e675458a35bc62b311c2d39">stopWhen</a> ($condition)</td></tr>
<tr class="separator:aaef453a53e675458a35bc62b311c2d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3826dc16e8bf535350c9a646b40a3e6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a3826dc16e8bf535350c9a646b40a3e6c">unfold</a> (callable $transformer=null)</td></tr>
<tr class="separator:a3826dc16e8bf535350c9a646b40a3e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cdd5131e7b8240b383f111e402b8d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#ac2cdd5131e7b8240b383f111e402b8d8">through</a> (callable $handler)</td></tr>
<tr class="separator:ac2cdd5131e7b8240b383f111e402b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ef2477f46e96a1bc6421237c905a4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a90ef2477f46e96a1bc6421237c905a4e">zip</a> ($items)</td></tr>
<tr class="separator:a90ef2477f46e96a1bc6421237c905a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdda1d3c440803947c39181f9637048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a5fdda1d3c440803947c39181f9637048">zipWith</a> ($items, $callable)</td></tr>
<tr class="separator:a5fdda1d3c440803947c39181f9637048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd852e1253e9544884322148a5b7fd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a8dd852e1253e9544884322148a5b7fd1">chunk</a> ($chunkSize)</td></tr>
<tr class="separator:a8dd852e1253e9544884322148a5b7fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcc52b3673b8df9425e52f13accb2a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#aedcc52b3673b8df9425e52f13accb2a1">isEmpty</a> ()</td></tr>
<tr class="separator:aedcc52b3673b8df9425e52f13accb2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa19d55b4bd3d64ce453980125370b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a1aa19d55b4bd3d64ce453980125370b3">unwrap</a> ()</td></tr>
<tr class="separator:a1aa19d55b4bd3d64ce453980125370b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66491f281b2dea60b17f584178c62a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a66491f281b2dea60b17f584178c62a8b">transpose</a> ()</td></tr>
<tr class="separator:a66491f281b2dea60b17f584178c62a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes the methods a <a class="el" href="class_cake_1_1_collection_1_1_collection.html">Collection</a> should implement. A collection is an immutable list of elements exposing a number of traversing and extracting method for generating other collections. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a40356bd2ce6d77017a4761f4d39bb4ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">append </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection as the result of concatenating the list of elements in this collection with the passed list of elements</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array&#160;|&#160;\Traversable</td><td class="paramname">$items</td><td>Items list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a3d28b4372c711f1dd84d91d03974e11a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buffered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection where the operations performed by this collection. No matter how many times the new collection is iterated, those operations will only be performed once.</p>
<p>This can also be used to make any non-rewindable iterator rewindable.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a8dd852e1253e9544884322148a5b7fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">chunk </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$chunkSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Breaks the collection into smaller arrays of the given size.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];</div><div class="line">$chunked = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a8dd852e1253e9544884322148a5b7fd1">chunk</a>(3)-&gt;toList();</div><div class="line"><span class="comment">// Returns [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11]]</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$chunkSize</td><td>The maximum size for each chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0276e393807dc8bed14aa61d40292d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">combine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$keyPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$valuePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$groupPath</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection where the values extracted based on a value path and then indexed by a key path. Optionally this method can produce parent groups based on a group property path.</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>, <span class="stringliteral">&#39;parent&#39;</span> =&gt; <span class="charliteral">&#39;a&#39;</span>],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 2, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;bar&#39;</span>, <span class="stringliteral">&#39;parent&#39;</span> =&gt; <span class="charliteral">&#39;b&#39;</span>],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 3, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;baz&#39;</span>, <span class="stringliteral">&#39;parent&#39;</span> =&gt; <span class="charliteral">&#39;a&#39;</span>],</div><div class="line">];</div><div class="line"></div><div class="line">$combined = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0276e393807dc8bed14aa61d40292d1e">combine</a>(<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;name&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[</div><div class="line"> 1 =&gt; <span class="stringliteral">&#39;foo&#39;</span>,</div><div class="line"> 2 =&gt; <span class="stringliteral">&#39;bar&#39;</span>,</div><div class="line"> 3 =&gt; <span class="stringliteral">&#39;baz&#39;</span>,</div><div class="line">];</div><div class="line"></div><div class="line">$combined = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0276e393807dc8bed14aa61d40292d1e">combine</a>(<span class="stringliteral">&#39;id&#39;</span>, <span class="stringliteral">&#39;name&#39;</span>, <span class="stringliteral">&#39;parent&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[</div><div class="line"> <span class="charliteral">&#39;a&#39;</span> =&gt; [1 =&gt; <span class="stringliteral">&#39;foo&#39;</span>, 3 =&gt; <span class="stringliteral">&#39;baz&#39;</span>],</div><div class="line"> <span class="charliteral">&#39;b&#39;</span> =&gt; [2 =&gt; <span class="stringliteral">&#39;bar&#39;</span>]</div><div class="line">];</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$keyPath</td><td>the column name path to use for indexing or a function returning the indexing key out of the provided element </td></tr>
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$valuePath</td><td>the column name path to use as the array value or a function returning the value out of the provided element </td></tr>
    <tr><td class="paramtype">callable&#160;|&#160;string&#160;|&#160;null</td><td class="paramname">$groupPath</td><td>the column name path to use as the parent grouping key or a function returning the key out of the provided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aba51c634aa895fc1cea39d6e0971a765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">compile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$preserveKeys</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates once all elements in this collection and executes all stacked operations of them, finally it returns a new collection with the result. This is useful for converting non-rewindable internal iterators into a collection that can be rewound and used multiple times.</p>
<p>A common use case is to re-use the same variable for calculating different data. In those cases it may be helpful and more performant to first compile a collection and then apply more operations to it.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$collection-&gt;map($mapper)-&gt;sortBy(<span class="stringliteral">&#39;age&#39;</span>)-&gt;extract(<span class="stringliteral">&#39;name&#39;</span>);</div><div class="line">$compiled = $collection-&gt;compile();</div><div class="line">$isJohnHere = $compiled-&gt;some($johnMatcher);</div><div class="line">$allButJohn = $compiled-&gt;filter($johnMatcher);</div></div><!-- fragment --><p>In the above example, had the collection not been compiled before, the iterations for <code>map</code>, <code>sortBy</code> and <code>extract</code> would've been executed twice: once for getting <code>$isJohnHere</code> and once for <code>$allButJohn</code></p>
<p>You can think of this method as a way to create save points for complex calculations in a collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">bool</td><td class="paramname">$preserveKeys</td><td>whether to use the keys returned by this collection as the array keys. Keep in mind that it is valid for iterators to return the same key for different elements, setting this value to false can help getting all items if keys are not important in the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ade2aea429e66ac043bb00a49bbd9467e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">contains </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if $value is present in this collection. Comparisons are made both by value and type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">mixed</td><td class="paramname">$value</td><td>The value to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if $value is present in this collection </dd></dl>

</div>
</div>
<a class="anchor" id="a0dc58f751b824a50403e11f533a49f94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">countBy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts a list into groups and returns a count for the number of elements in each group. Similar to groupBy, but instead of returning a list of values, returns a count for the number of values in that group.</p>
<p>When $callback is a string it should be a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 10],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 2, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;bar&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 11],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 3, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;baz&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 10],</div><div class="line">];</div><div class="line"></div><div class="line">$group = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0dc58f751b824a50403e11f533a49f94">countBy</a>(<span class="stringliteral">&#39;parent_id&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Or</span></div><div class="line">$group = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a0dc58f751b824a50403e11f533a49f94">countBy</a>(<span class="keyword">function</span> ($e) {</div><div class="line"> <span class="keywordflow">return</span> $e[<span class="stringliteral">&#39;parent_id&#39;</span>];</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[</div><div class="line"> 10 =&gt; 2,</div><div class="line"> 11 =&gt; 1</div><div class="line">];</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$callback</td><td>the callback or column name to use for indexing or a function returning the indexing key out of the provided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5626b35c368ad61290c795cb20770f94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">each </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes the passed callable for each of the elements in this collection and passes both the value and key for them on each step. Returns the same collection for chaining.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$collection = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a5626b35c368ad61290c795cb20770f94">each</a>(<span class="keyword">function</span> ($value, $key) {</div><div class="line"> echo <span class="stringliteral">&quot;Element $key: $value&quot;</span>;</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$c</td><td>callable function that will receive each of the elements in this collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a60fc2a392280304d87c6e7f9de6f28bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">every </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all values in this collection pass the truth test provided in the callback.</p>
<p>Each time the callback is executed it will receive the value of the element in the current iteration and the key of the element as arguments, in that order.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$overTwentyOne = (<span class="keyword">new</span> Collection([24, 45, 60, 15]))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a60fc2a392280304d87c6e7f9de6f28bf">every</a>(<span class="keyword">function</span> ($value, $key) {</div><div class="line"> <span class="keywordflow">return</span> $value &gt; 21;</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$c</td><td>a callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if for all elements in this collection the provided callback returns true, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a87da587eaaf21fe62c6bcfd3a1e67916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">extract </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$matcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection containing the column or property value found in each of the elements, as requested in the $matcher param.</p>
<p>The matcher can be a string with a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p>
<p>If a column or property could not be found for a particular element in the collection, that position is filled with null.</p>
<h3>Example:</h3>
<p>Extract the user name for all comments in the array:</p>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;cool&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Mark&#39;</span>]],</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;very cool&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Renan&#39;</span>]]</div><div class="line">];</div><div class="line">$extracted = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a87da587eaaf21fe62c6bcfd3a1e67916">extract</a>(<span class="stringliteral">&#39;comment.user.name&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[<span class="stringliteral">&#39;Mark&#39;</span>, <span class="stringliteral">&#39;Renan&#39;</span>]</div></div><!-- fragment --><p>It is also possible to extract a flattened collection out of nested properties</p>
<div class="fragment"><div class="line"> $items = [</div><div class="line">     [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;votes&#39;</span> =&gt; [[<span class="stringliteral">&#39;value&#39;</span> =&gt; 1], [<span class="stringliteral">&#39;value&#39;</span> =&gt; 2], [<span class="stringliteral">&#39;value&#39;</span> =&gt; 3]]],</div><div class="line">     [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;votes&#39;</span> =&gt; [[<span class="stringliteral">&#39;value&#39;</span> =&gt; 4]]</div><div class="line">];</div><div class="line">$extracted = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a87da587eaaf21fe62c6bcfd3a1e67916">extract</a>(<span class="stringliteral">&#39;comment.votes.{*}.value&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Result will contain</span></div><div class="line">[1, 2, 3, 4]</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$matcher</td><td>a dot separated string symbolizing the path to follow inside the hierarchy of each value so that the column can be extracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a171f012cd03fe8f5761637a101c0fa47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">filter </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$c</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks through each value in the collection, and returns another collection with all the values that pass a truth test. Only the values for which the callback returns true will be present in the resulting collection.</p>
<p>Each time the callback is executed it will receive the value of the element in the current iteration, the key of the element and this collection as arguments, in that order.</p>
<h3>Example:</h3>
<p>Filtering odd numbers in an array, at the end only the value 2 will be present in the resulting collection:</p>
<div class="fragment"><div class="line">$collection = (<span class="keyword">new</span> Collection([1, 2, 3]))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a171f012cd03fe8f5761637a101c0fa47">filter</a>(<span class="keyword">function</span> ($value, $key) {</div><div class="line"> <span class="keywordflow">return</span> $value % 2 === 0;</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;null</td><td class="paramname">$c</td><td>the method that will receive each of the elements and returns true whether or not they should be in the resulting collection. If left null, a callback that filters out falsey values will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac73eef9ff76ea330c0dab36ca448b90d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the first result in this collection</p>
<dl class="section return"><dt>Returns</dt><dd>mixed The first value in the collection will be returned. </dd></dl>

<p>Implemented in <a class="el" href="class_cake_1_1_o_r_m_1_1_result_set.html#ac73eef9ff76ea330c0dab36ca448b90d">ResultSet</a>.</p>

</div>
</div>
<a class="anchor" id="a4e850fe1e72606cb9c22de6a3505e225"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">firstMatch </td>
          <td>(</td>
          <td class="paramtype">array&#160;</td>
          <td class="paramname"><em>$conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the first result matching all of the key-value pairs listed in conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array</td><td class="paramname">$conditions</td><td>a key-value list of conditions where the key is a property path as accepted by <code><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a87da587eaaf21fe62c6bcfd3a1e67916">Collection::extract</a></code>, and the value the condition against with each element will be matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_cake_1_1_collection.html#a547026ddca8b42fd1e96f60df53b295f">match()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>mixed </dd></dl>

</div>
</div>
<a class="anchor" id="ab25082bae9e5093235499b59c8712168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">groupBy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits a collection into sets, grouped by the result of running each value through the callback. If $callback is a string instead of a callable, groups by the property named by $callback on each of the values.</p>
<p>When $callback is a string it should be a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 10],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 2, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;bar&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 11],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 3, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;baz&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 10],</div><div class="line">];</div><div class="line"></div><div class="line">$group = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#ab25082bae9e5093235499b59c8712168">groupBy</a>(<span class="stringliteral">&#39;parent_id&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Or</span></div><div class="line">$group = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#ab25082bae9e5093235499b59c8712168">groupBy</a>(<span class="keyword">function</span> ($e) {</div><div class="line"> <span class="keywordflow">return</span> $e[<span class="stringliteral">&#39;parent_id&#39;</span>];</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[</div><div class="line"> 10 =&gt; [</div><div class="line">     [<span class="stringliteral">&#39;id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 10],</div><div class="line">     [<span class="stringliteral">&#39;id&#39;</span> =&gt; 3, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;baz&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 10],</div><div class="line"> ],</div><div class="line"> 11 =&gt; [</div><div class="line">     [<span class="stringliteral">&#39;id&#39;</span> =&gt; 2, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;bar&#39;</span>, <span class="stringliteral">&#39;parent_id&#39;</span> =&gt; 11],</div><div class="line"> ]</div><div class="line">];</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$callback</td><td>the callback or column name to use for grouping or a function returning the grouping key out of the provided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac35aa5525146f287686cc010a4aa0927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">indexBy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list and a callback function that returns a key for each element in the list (or a property name), returns an object with an index of each item. Just like groupBy, but for when you know your keys are unique.</p>
<p>When $callback is a string it should be a property name to extract or a dot separated path of properties that should be followed to get the last one in the path.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 2, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;bar&#39;</span>],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 3, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;baz&#39;</span>],</div><div class="line">];</div><div class="line"></div><div class="line">$indexed = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#ac35aa5525146f287686cc010a4aa0927">indexBy</a>(<span class="stringliteral">&#39;id&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Or</span></div><div class="line">$indexed = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#ac35aa5525146f287686cc010a4aa0927">indexBy</a>(<span class="keyword">function</span> ($e) {</div><div class="line"> <span class="keywordflow">return</span> $e[<span class="stringliteral">&#39;id&#39;</span>];</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[</div><div class="line"> 1 =&gt; [<span class="stringliteral">&#39;id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;foo&#39;</span>],</div><div class="line"> 3 =&gt; [<span class="stringliteral">&#39;id&#39;</span> =&gt; 3, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;baz&#39;</span>],</div><div class="line"> 2 =&gt; [<span class="stringliteral">&#39;id&#39;</span> =&gt; 2, <span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;bar&#39;</span>],</div><div class="line">];</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$callback</td><td>the callback or column name to use for indexing or a function returning the indexing key out of the provided element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abc55e55fd4a6f43679523e26747cee1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">insert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection containing each of the elements found in <code>$values</code> as a property inside the corresponding elements in this collection. The property where the values will be inserted is described by the <code>$path</code> parameter.</p>
<p>The $path can be a string with a property name or a dot separated path of properties that should be followed to get the last one in the path.</p>
<p>If a column or property could not be found for a particular element in the collection as part of the path, the element will be kept unchanged.</p>
<h3>Example:</h3>
<p>Insert ages into a collection containing users:</p>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;cool&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Mark&#39;</span>]],</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;awesome&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Renan&#39;</span>]]</div><div class="line">];</div><div class="line">$ages = [25, 28];</div><div class="line">$inserted = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#abc55e55fd4a6f43679523e26747cee1a">insert</a>(<span class="stringliteral">&#39;comment.user.age&#39;</span>, $ages);</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;cool&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Mark&#39;</span>, <span class="stringliteral">&#39;age&#39;</span> =&gt; 25]],</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;awesome&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Renan&#39;</span>, <span class="stringliteral">&#39;age&#39;</span> =&gt; 28]]</div><div class="line">];</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$path</td><td>a dot separated string symbolizing the path to follow inside the hierarchy of each value so that the value can be inserted </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$values</td><td>The values to be inserted at the specified path, values are matched with the elements in this collection by its positional index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aedcc52b3673b8df9425e52f13accb2a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not there are elements in this collection</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items [1, 2, 3];</div><div class="line">(<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#aedcc52b3673b8df9425e52f13accb2a1">isEmpty</a>(); <span class="comment">// false</span></div></div><!-- fragment --><div class="fragment"><div class="line">(<span class="keyword">new</span> Collection([]))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#aedcc52b3673b8df9425e52f13accb2a1">isEmpty</a>(); <span class="comment">// true</span></div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="ad402d8679325bc514874370f02b5c2ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jsonSerialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a result set into JSON.</p>
<p>Part of JsonSerializable interface.</p>
<dl class="section return"><dt>Returns</dt><dd>array The data to convert to JSON </dd></dl>

</div>
</div>
<a class="anchor" id="ac90cadb327363232bb2d83a4f8ebd613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the last result in this collection</p>
<dl class="section return"><dt>Returns</dt><dd>mixed The last value in the collection will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="acd9f25f41c3449fd451c3a4516ccb160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">listNested </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$dir</em> = <code>'desc'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$nestingKey</em> = <code>'children'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection with each of the elements of this collection after flattening the tree structure. The tree structure is defined by nesting elements under a key with a known name. It is possible to specify such name by using the '$nestingKey' parameter.</p>
<p>By default all elements in the tree following a Depth First Search will be returned, that is, elements from the top parent to the leaves for each branch.</p>
<p>It is possible to return all elements from bottom to top using a Breadth First Search approach by passing the '$dir' parameter with 'asc'. That is, it will return all elements for the same tree depth first and from bottom to top.</p>
<p>Finally, you can specify to only get a collection with the leaf nodes in the tree structure. You do so by passing 'leaves' in the first argument.</p>
<p>The possible values for the first argument are aliases for the following constants and it is valid to pass those instead of the alias:</p>
<ul>
<li>desc: TreeIterator::SELF_FIRST</li>
<li>asc: TreeIterator::CHILD_FIRST</li>
<li>leaves: TreeIterator::LEAVES_ONLY</li>
</ul>
<h3>Example:</h3>
<div class="fragment"><div class="line">$collection = <span class="keyword">new</span> Collection([</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 1, <span class="stringliteral">&#39;children&#39;</span> =&gt; [[<span class="stringliteral">&#39;id&#39;</span> =&gt; 2, <span class="stringliteral">&#39;children&#39;</span> =&gt; [[<span class="stringliteral">&#39;id&#39;</span> =&gt; 3]]]]],</div><div class="line"> [<span class="stringliteral">&#39;id&#39;</span> =&gt; 4, <span class="stringliteral">&#39;children&#39;</span> =&gt; [[<span class="stringliteral">&#39;id&#39;</span> =&gt; 5]]]</div><div class="line">]);</div><div class="line">$flattenedIds = $collection-&gt;listNested()-&gt;extract(<span class="stringliteral">&#39;id&#39;</span>); <span class="comment">// Yields [1, 2, 3, 4, 5]</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;int</td><td class="paramname">$dir</td><td>The direction in which to return the elements </td></tr>
    <tr><td class="paramtype">string&#160;|&#160;callable</td><td class="paramname">$nestingKey</td><td>The key name under which children are nested or a callable function that will return the children list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a12903585bd417382e695a2390ffd626b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns another collection after modifying each of the values in this one using the provided callable.</p>
<p>Each time the callback is executed it will receive the value of the element in the current iteration, the key of the element and this collection as arguments, in that order.</p>
<h3>Example:</h3>
<p>Getting a collection of booleans where true indicates if a person is female:</p>
<div class="fragment"><div class="line">$collection = (<span class="keyword">new</span> Collection($people))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a12903585bd417382e695a2390ffd626b">map</a>(<span class="keyword">function</span> ($person, $key) {</div><div class="line"> <span class="keywordflow">return</span> $person-&gt;gender === <span class="stringliteral">&#39;female&#39;</span>;</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$c</td><td>the method that will receive each of the elements and returns the new value for the key that is being iterated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a623727743cb9c3dde4fb86afb61f1f43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">match </td>
          <td>(</td>
          <td class="paramtype">array&#160;</td>
          <td class="paramname"><em>$conditions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks through each value in the list, returning a <a class="el" href="class_cake_1_1_collection_1_1_collection.html">Collection</a> of all the values that contain all of the key-value pairs listed in $conditions.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;cool&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Mark&#39;</span>]],</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;very cool&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Renan&#39;</span>]]</div><div class="line">];</div><div class="line"></div><div class="line">$extracted = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a623727743cb9c3dde4fb86afb61f1f43">match</a>([<span class="stringliteral">&#39;user.name&#39;</span> =&gt; <span class="stringliteral">&#39;Renan&#39;</span>]);</div><div class="line"></div><div class="line"><span class="comment">// Result will look like this when converted to array</span></div><div class="line">[</div><div class="line"> [<span class="stringliteral">&#39;comment&#39;</span> =&gt; [<span class="stringliteral">&#39;body&#39;</span> =&gt; <span class="stringliteral">&#39;very cool&#39;</span>, <span class="stringliteral">&#39;user&#39;</span> =&gt; [<span class="stringliteral">&#39;name&#39;</span> =&gt; <span class="stringliteral">&#39;Renan&#39;</span>]]</div><div class="line">]</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">array</td><td class="paramname">$conditions</td><td>a key-value list of conditions where the key is a property path as accepted by `Collection<a class="el" href="namespace_cake_1_1_collection.html#ab976213e20b27571fa2041192679e0c2">extract</a>, and the value the condition against with each element will be matched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="adf0938e9829f75c1b1509307883c9f35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">max </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$type</em> = <code>SORT_NUMERIC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the top element in this collection after being sorted by a property. Check the sortBy method for information on the callback and $type parameters</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line"><span class="comment">// For a collection of employees</span></div><div class="line">$max = $collection-&gt;max(<span class="stringliteral">&#39;age&#39;</span>);</div><div class="line">$max = $collection-&gt;max(<span class="stringliteral">&#39;user.salary&#39;</span>);</div><div class="line">$max = $collection-&gt;max(<span class="keyword">function</span> ($e) {</div><div class="line"> <span class="keywordflow">return</span> $e-&gt;get(<span class="stringliteral">&#39;user&#39;</span>)-&gt;get(<span class="stringliteral">&#39;salary&#39;</span>);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// Display employee name</span></div><div class="line">echo $max-&gt;name;</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$callback</td><td>the callback or column name to use for sorting </td></tr>
    <tr><td class="paramtype">int</td><td class="paramname">$type</td><td>the type of comparison to perform, either SORT_STRING SORT_NUMERIC or SORT_NATURAL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_cake_1_1_collection.html#a9ba4a21723a0b7f91b85476254472435">sortBy()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>mixed The value of the top element in the collection </dd></dl>

</div>
</div>
<a class="anchor" id="a4777b629ffa559c0cfa11ed02fda1662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">min </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$type</em> = <code>SORT_NUMERIC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the bottom element in this collection after being sorted by a property. Check the sortBy method for information on the callback and $type parameters</p>
<h3>Examples:</h3>
<div class="fragment"><div class="line"><span class="comment">// For a collection of employees</span></div><div class="line">$min = $collection-&gt;min(<span class="stringliteral">&#39;age&#39;</span>);</div><div class="line">$min = $collection-&gt;min(<span class="stringliteral">&#39;user.salary&#39;</span>);</div><div class="line">$min = $collection-&gt;min(<span class="keyword">function</span> ($e) {</div><div class="line"> <span class="keywordflow">return</span> $e-&gt;get(<span class="stringliteral">&#39;user&#39;</span>)-&gt;get(<span class="stringliteral">&#39;salary&#39;</span>);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// Display employee name</span></div><div class="line">echo $min-&gt;name;</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$callback</td><td>the callback or column name to use for sorting </td></tr>
    <tr><td class="paramtype">int</td><td class="paramname">$type</td><td>the type of comparison to perform, either SORT_STRING SORT_NUMERIC or SORT_NATURAL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_cake_1_1_collection.html#a9ba4a21723a0b7f91b85476254472435">sortBy()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>mixed The value of the bottom element in the collection </dd></dl>

</div>
</div>
<a class="anchor" id="a840571bac23a95974b848bf3bf5c5012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$idPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$parentPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$nestingKey</em> = <code>'children'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection where the values are nested in a tree-like structure based on an id property path and a parent id property path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$idPath</td><td>the column name path to use for determining whether an element is parent of another </td></tr>
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$parentPath</td><td>the column name path to use for determining whether an element is child of another </td></tr>
    <tr><td class="paramtype">string</td><td class="paramname">$nestingKey</td><td>The key name under which children are nested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="acae0a549be85abcd70d503a64c3126dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reduce </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$zero</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Folds the values in this collection to a single value, as the result of applying the callback function to all elements. $zero is the initial state of the reduction, and each successive step of it should be returned by the callback function. If $zero is omitted the first value of the collection will be used in its place and reduction will start from the second item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$c</td><td>The callback function to be called </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$zero</td><td>The state of reduction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="adaef54e202c1bcfec248c3c7acd8de2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reject </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks through each value in the collection, and returns another collection with all the values that do not pass a truth test. This is the opposite of <code>filter</code>.</p>
<p>Each time the callback is executed it will receive the value of the element in the current iteration, the key of the element and this collection as arguments, in that order.</p>
<h3>Example:</h3>
<p>Filtering even numbers in an array, at the end only values 1 and 3 will be present in the resulting collection:</p>
<div class="fragment"><div class="line">$collection = (<span class="keyword">new</span> Collection([1, 2, 3]))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#adaef54e202c1bcfec248c3c7acd8de2d">reject</a>(<span class="keyword">function</span> ($value, $key) {</div><div class="line"> <span class="keywordflow">return</span> $value % 2 === 0;</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$c</td><td>the method that will receive each of the elements and returns true whether or not they should be out of the resulting collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0799a938e9d3e0f777a6d7a24f64977f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$size</em> = <code>10</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection with maximum $size random elements from this collection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$size</td><td>the maximum number of elements to randomly take from this collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afce59714eca34395b19320a00ca1c7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shuffle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection with the elements placed in a random order, this function does not preserve the original keys in the collection.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0b5aee77a2ffc76c05cf670a165fb2a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">skip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$howMany</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection that will skip the specified amount of elements at the beginning of the iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$howMany</td><td>The number of elements to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a96ecae2c1a0c69f0eef231abf8b4b4ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">some </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if any of the values in this collection pass the truth test provided in the callback.</p>
<p>Each time the callback is executed it will receive the value of the element in the current iteration and the key of the element as arguments, in that order.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$hasYoungPeople = (<span class="keyword">new</span> Collection([24, 45, 15]))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a60fc2a392280304d87c6e7f9de6f28bf">every</a>(<span class="keyword">function</span> ($value, $key) {</div><div class="line"> <span class="keywordflow">return</span> $value &lt; 21;</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$c</td><td>a callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if for all elements in this collection the provided callback returns true, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2c34e2bd3e1578c8dd19023e97948a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sortBy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$dir</em> = <code>SORT_DESC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$type</em> = <code>SORT_NUMERIC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a sorted iterator out of the elements in this collection, ranked in ascending order by the results of running each value through a callback. $callback can also be a string representing the column or property name.</p>
<p>The callback will receive as its first argument each of the elements in $items, the value returned by the callback will be used as the value for sorting such element. Please note that the callback function could be called more than once per element.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = $collection-&gt;sortBy(<span class="keyword">function</span> ($user) {</div><div class="line"> <span class="keywordflow">return</span> $user-&gt;age;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// alternatively</span></div><div class="line">$items = $collection-&gt;sortBy(<span class="stringliteral">&#39;age&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// or use a property path</span></div><div class="line">$items = $collection-&gt;sortBy(<span class="stringliteral">&#39;department.name&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// output all user name order by their age in descending order</span></div><div class="line"><span class="keywordflow">foreach</span> ($items as $user) {</div><div class="line"> echo $user-&gt;name;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;string</td><td class="paramname">$callback</td><td>the callback or column name to use for sorting </td></tr>
    <tr><td class="paramtype">int</td><td class="paramname">$dir</td><td>either SORT_DESC or SORT_ASC </td></tr>
    <tr><td class="paramtype">int</td><td class="paramname">$type</td><td>the type of comparison to perform, either SORT_STRING SORT_NUMERIC or SORT_NATURAL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aaef453a53e675458a35bc62b311c2d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stopWhen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new collection that when iterated will stop yielding results if the provided condition evaluates to false.</p>
<p>This is handy for dealing with infinite iterators or any generator that could start returning invalid elements at a certain point. For example, when reading lines from a file stream you may want to stop the iteration after a certain value is reached.</p>
<h3>Example:</h3>
<p>Get an array of lines in a CSV file until the timestamp column is less than a date</p>
<div class="fragment"><div class="line">$lines = (<span class="keyword">new</span> Collection($fileLines))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#aaef453a53e675458a35bc62b311c2d39">stopWhen</a>(<span class="keyword">function</span> ($value, $key) {</div><div class="line"> <span class="keywordflow">return</span> (<span class="keyword">new</span> <a class="code" href="namespace_date_time.html">DateTime</a>($value))-&gt;format(<span class="charliteral">&#39;Y&#39;</span>) &lt; 2012;</div><div class="line">})</div><div class="line">-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a5d268fad8337f989252cd548a27f7400">toArray</a>();</div></div><!-- fragment --><p>Get elements until the first unapproved message is found:</p>
<div class="fragment"><div class="line">$comments = (<span class="keyword">new</span> Collection($comments))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#aaef453a53e675458a35bc62b311c2d39">stopWhen</a>([<span class="stringliteral">&#39;is_approved&#39;</span> =&gt; <span class="keyword">false</span>]);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$condition</td><td>the method that will receive each of the elements and returns false when the iteration should be stopped. If an array, it will be interpreted as a key-value list of conditions where the key is a property path as accepted by <code><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html#a87da587eaaf21fe62c6bcfd3a1e67916">Collection::extract</a></code>, and the value the condition against with each element will be matched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a778a968468403f1489fdd07937efaea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sumOf </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$matcher</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total sum of all the values extracted with $matcher or of this collection.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = [</div><div class="line"> [<span class="stringliteral">&#39;invoice&#39;</span> =&gt; [<span class="stringliteral">&#39;total&#39;</span> =&gt; 100],</div><div class="line"> [<span class="stringliteral">&#39;invoice&#39;</span> =&gt; [<span class="stringliteral">&#39;total&#39;</span> =&gt; 200]</div><div class="line">];</div><div class="line"></div><div class="line">$total = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a778a968468403f1489fdd07937efaea1">sumOf</a>(<span class="stringliteral">&#39;invoice.total&#39;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Total: 300</span></div><div class="line"></div><div class="line">$total = (<span class="keyword">new</span> Collection([1, 2, 3]))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a778a968468403f1489fdd07937efaea1">sumOf</a>();</div><div class="line"><span class="comment">// Total: 6</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string&#160;|&#160;callable&#160;|&#160;null</td><td class="paramname">$matcher</td><td>The property name to sum or a function If no value is passed, an identity function will be used. that will return the value of the property to sum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float|int </dd></dl>

</div>
</div>
<a class="anchor" id="a9579f823a6c66ac1c968eb6b8a21d23b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">take </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$size</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$from</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new collection with maximum $size elements in the internal order this collection was created. If a second parameter is passed, it will determine from what position to start taking elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$size</td><td>the maximum number of elements to take from this collection </td></tr>
    <tr><td class="paramtype">int</td><td class="paramname">$from</td><td>A positional offset from where to take the elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac2cdd5131e7b8240b383f111e402b8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">through </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Passes this collection through a callable as its first argument. This is useful for decorating the full collection with another object.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = [1, 2, 3];</div><div class="line">$decorated = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#ac2cdd5131e7b8240b383f111e402b8d8">through</a>(<span class="keyword">function</span> ($collection) {</div><div class="line">     <span class="keywordflow">return</span> <span class="keyword">new</span> MyCustomCollection($collection);</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable</td><td class="paramname">$handler</td><td>A callable function that will receive this collection as first argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5d268fad8337f989252cd548a27f7400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">toArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$preserveKeys</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array representation of the results</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">bool</td><td class="paramname">$preserveKeys</td><td>whether to use the keys returned by this collection as the array keys. Keep in mind that it is valid for iterators to return the same key for different elements, setting this value to false can help getting all items if keys are not important in the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array </dd></dl>

</div>
</div>
<a class="anchor" id="af7b8e53645e6f61a6e2a9cfe7b56de70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">toList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an numerically-indexed array representation of the results. This is equivalent to calling <code>toArray(false)</code></p>
<dl class="section return"><dt>Returns</dt><dd>array </dd></dl>

</div>
</div>
<a class="anchor" id="a66491f281b2dea60b17f584178c62a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transpose rows and columns into columns and rows</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items = [</div><div class="line">      [<span class="stringliteral">&#39;Products&#39;</span>, <span class="stringliteral">&#39;2012&#39;</span>, <span class="stringliteral">&#39;2013&#39;</span>, <span class="stringliteral">&#39;2014&#39;</span>],</div><div class="line">      [<span class="stringliteral">&#39;Product A&#39;</span>, <span class="stringliteral">&#39;200&#39;</span>, <span class="stringliteral">&#39;100&#39;</span>, <span class="stringliteral">&#39;50&#39;</span>],</div><div class="line">      [<span class="stringliteral">&#39;Product B&#39;</span>, <span class="stringliteral">&#39;300&#39;</span>, <span class="stringliteral">&#39;200&#39;</span>, <span class="stringliteral">&#39;100&#39;</span>],</div><div class="line">      [<span class="stringliteral">&#39;Product C&#39;</span>, <span class="stringliteral">&#39;400&#39;</span>, <span class="stringliteral">&#39;300&#39;</span>, <span class="stringliteral">&#39;200&#39;</span>],</div><div class="line">]</div><div class="line"></div><div class="line">$transpose = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a66491f281b2dea60b17f584178c62a8b">transpose</a>()-&gt;toList();</div><div class="line"></div><div class="line"><span class="comment">// Returns</span></div><div class="line"><span class="comment">// [</span></div><div class="line"><span class="comment">//     [&#39;Products&#39;, &#39;Product A&#39;, &#39;Product B&#39;, &#39;Product C&#39;],</span></div><div class="line"><span class="comment">//     [&#39;2012&#39;, &#39;200&#39;, &#39;300&#39;, &#39;400&#39;],</span></div><div class="line"><span class="comment">//     [&#39;2013&#39;, &#39;100&#39;, &#39;200&#39;, &#39;300&#39;],</span></div><div class="line"><span class="comment">//     [&#39;2014&#39;, &#39;50&#39;, &#39;100&#39;, &#39;200&#39;],</span></div><div class="line"><span class="comment">// ]</span></div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a3826dc16e8bf535350c9a646b40a3e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unfold </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$transformer</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new collection where the items are the concatenation of the lists of items generated by the transformer function applied to each item in the original collection.</p>
<p>The transformer function will receive the value and the key for each of the items in the collection, in that order, and it must return an array or a Traversable object that can be concatenated to the final result.</p>
<p>If no transformer function is passed, an "identity" function will be used. This is useful when each of the elements in the source collection are lists of items to be appended one after another.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$items [[1, 2, 3], [4, 5]];</div><div class="line">$unfold = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a3826dc16e8bf535350c9a646b40a3e6c">unfold</a>(); <span class="comment">// Returns [1, 2, 3, 4, 5]</span></div></div><!-- fragment --><p>Using a transformer</p>
<div class="fragment"><div class="line">$items [1, 2, 3];</div><div class="line">$allItems = (<span class="keyword">new</span> Collection($items))-&gt;<a class="code" href="interface_cake_1_1_collection_1_1_collection_interface.html#a3826dc16e8bf535350c9a646b40a3e6c">unfold</a>(<span class="keyword">function</span> ($page) {</div><div class="line"> <span class="keywordflow">return</span> $service-&gt;fetchPage($page)-&gt;toArray();</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;null</td><td class="paramname">$transformer</td><td>A callable function that will receive each of the items in the collection and should return an array or Traversable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1aa19d55b4bd3d64ce453980125370b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unwrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the closest nested iterator that can be safely traversed without losing any possible transformations. This is used mainly to remove empty IteratorIterator wrappers that can only slowdown the iteration process.</p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a90ef2477f46e96a1bc6421237c905a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combines the elements of this collection with each of the elements of the passed iterables, using their positional index as a reference.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$collection = <span class="keyword">new</span> Collection([1, 2]);</div><div class="line">$collection-&gt;zip([3, 4], [5, 6])-&gt;toList(); <span class="comment">// returns [[1, 3, 5], [2, 4, 6]]</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array|</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fdda1d3c440803947c39181f9637048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zipWith </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Combines the elements of this collection with each of the elements of the passed iterables, using their positional index as a reference.</p>
<p>The resulting element will be the return value of the $callable function.</p>
<h3>Example:</h3>
<div class="fragment"><div class="line">$collection = <span class="keyword">new</span> Collection([1, 2]);</div><div class="line">$zipped = $collection-&gt;zipWith([3, 4], [5, 6], <span class="keyword">function</span> () {</div><div class="line">  <span class="keywordflow">return</span> array_sum(func_get_args());</div><div class="line">});</div><div class="line">$zipped-&gt;toList(); <span class="comment">// returns [9, 12]; [(1 + 3 + 5), (2 + 4 + 6)]</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array|</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>vendor/cakephp/cakephp/src/Collection/CollectionInterface.php</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_cake.html">Cake</a></li><li class="navelem"><a class="el" href="namespace_cake_1_1_collection.html">Collection</a></li><li class="navelem"><a class="el" href="interface_cake_1_1_collection_1_1_collection_interface.html">CollectionInterface</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
